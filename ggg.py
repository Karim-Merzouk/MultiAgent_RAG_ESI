# -*- coding: utf-8 -*-
"""ggg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-OTVMUBrEu6aK5dN2PPhIQnkCHTfKgYe
"""

from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.document_loaders import TextLoader, WebBaseLoader, PyPDFLoader, DirectoryLoader, UnstructuredMarkdownLoader
import bs4
import os

# Document loading
loader = DirectoryLoader(
    path="dd",  # Replace with your folder path
    loader_cls=UnstructuredMarkdownLoader,
    use_multithreading=True
)

txt = loader.load()
from langchain.embeddings.sentence_transformer import SentenceTransformerEmbeddings
from langchain_community.vectorstores import FAISS
from pydantic.v1 import BaseModel, Field
import os

# Add this before your FAISS imports
class VectorStoreConfig(BaseModel):
    class Config:
        arbitrary_types_allowed = True


# Text splitting
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000,
    chunk_overlap=200,
    separators=[
        # ----- Markdown -----
        r"\n# ", r"\n## ", r"\n### ", r"\n#### ",
        r"\n```\n",
        r"\n\*\*\*\n", r"\n---\n",

        # ----- LaTeX/Math -----
        r"\n\\begin{equation}",
        r"\n\\begin{align}",
        r"\n\\section{", r"\n\\subsection{",
        r"\n\$\$", r"\n\\\[",

        # ----- C Code -----
        r"\n}\n",
        r"\n// -{4,}\n",
        r"\n#ifdef ", r"\n#endif",
        r"\n}\n\n",

        # ----- Assembly -----
        r"\n\.section\s",
        r"\n\.global\s",
        r"\n[a-zA-Z_]+:\n",
        r"\n; -{4,}\n",

        # ----- Generic Fallbacks -----
        r"\n\n", r"\n", r" ", r""
    ],
    is_separator_regex=True,
    keep_separator=True,
    strip_whitespace=True,
)
fdocs = text_splitter.split_documents(txt)

# Embedding with CPU optimization
embeddings = SentenceTransformerEmbeddings(
    model_name="all-MiniLM-L12-v2",
    model_kwargs={"device": "cpu"},
    encode_kwargs={
        "batch_size": 64,
        "normalize_embeddings": True
    }
)

# Create FAISS index
db = FAISS.from_documents(
    documents=fdocs,
    embedding=embeddings,
    normalize_L2=True
)

# To load it back later:
# loaded_db = FAISS.load_local(save_directory, embeddings)

# Now let's modify to use GROQ API instead of Ollama
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain_groq import ChatGroq  # Import the GROQ chat model
from langchain_core.prompts import ChatPromptTemplate
import os

# Set your GROQ API key - make sure to keep this secure!
# Import API key from environment variables or .env file

# Load variables from .env file into environment
load_dotenv()

# Access API key from environment variables
os.environ["GROQ_API_KEY"] = os.getenv("GROQ_API_KEY")

# Initialize the GROQ LLM - replaced Ollama with GROQ
llm = ChatGroq(
    # model="llama3-70b-8192",  # You can choose "mixtral-8x7b-32768" or other models
    # You can choose "mixtral-8x7b-32768" or other models
    model='llama-3.3-70b-versatile',
    temperature=0,
    max_tokens=32768,  # Control response length
)

# The prompt template remains the same
prompt = ChatPromptTemplate.from_template(r'''[Contexte] {context}
[Question] {input}
# Syntaxe D√©taill√©e du Langage Z

## 1. Introduction et Objectifs du Langage Z









Le langage Z est un langage algorithmique con√ßu principalement √† des fins p√©dagogiques. Son objectif est d'enseigner l'algorithmique et les structures de donn√©es en permettant aux utilisateurs d'√©crire des algorithmes abstraits. Ces algorithmes sont bas√©s sur des mod√®les de machines abstraites, ce qui permet de se concentrer sur la logique de r√©solution de probl√®mes avant de passer √† une impl√©mentation dans un langage de programmation sp√©cifique comme Pascal ou C.

**Caract√©ristiques Cl√©s pour l'IA :**
* Abstraction de la repr√©sentation m√©moire.
* Syntaxe claire et structur√©e, facilitant l'analyse et la g√©n√©ration.
* Support des structures de donn√©es fondamentales.
* Modularit√© via les actions et les fonctions.

## 2. Structure G√©n√©rale d'un Z-Algorithme

Un Z-algorithme est organis√© en modules. Le premier module est toujours le module principal. Les modules suivants peuvent √™tre des actions (proc√©dures) ou des fonctions.

```Z
ALGORITHME Nom_Algorithme  // Optionnel, mais bon pour la clart√©

SOIENT
    // Section des d√©clarations globales
    // D√©claration des constantes globales
    // D√©claration des types globaux
    // D√©claration des variables globales
    // Annonces des modules (actions et fonctions) qui seront d√©finis plus bas

DEBUT // D√©but du module principal
    // Instructions du module principal
FIN // Fin du module principal

// D√©finition des modules (Actions et Fonctions) annonc√©s
ACTION Nom_Action_1 (param√®tres)
    SOIENT
        // D√©clarations locales √† l'action
    DEBUT
        // Instructions de l'action
    FIN

FONCTION Nom_Fonction_1 (param√®tres) : Type_Retour
    SOIENT
        // D√©clarations locales √† la fonction
    DEBUT
        // Instructions de la fonction
        Nom_Fonction_1 := Valeur_De_Retour // Instruction de retour
    FIN

// ... autres actions et fonctions
```

**Points importants pour l'IA :**
* Identifier la d√©limitation claire entre la section `SOIENT` (d√©clarations) et `DEBUT`/`FIN` (bloc d'instructions).
* Reconna√Ætre le module principal comme point d'entr√©e.
* Comprendre la port√©e des variables (globales vs. locales √† un module).
* Les annonces de modules dans `SOIENT` avant leur d√©finition compl√®te.

 3. Commentaires
Les commentaires sont essentiels pour la lisibilit√© et peuvent √™tre ignor√©s par l'interpr√©teur ou le compilateur.


**Points importants pour l'IA :**
* Le mod√®le doit apprendre √† identifier et potentiellement ignorer le contenu des commentaires lors de l'analyse de la logique du code.
* Lors de la g√©n√©ration de code, le mod√®le pourrait √™tre entra√Æn√© √† ins√©rer des commentaires pertinents.

 4. Identificateurs

Les identificateurs sont les noms donn√©s aux variables, constantes, types, actions, fonctions, etc.
* Doivent commencer par une lettre.
* Peuvent contenir des lettres, des chiffres et le caract√®re soulign√© (`_`).
* Ne sont pas sensibles √† la casse (par convention, mais √† v√©rifier si les outils fournis le sont).
* Ne doivent pas √™tre des mots-cl√©s r√©serv√©s du langage.

**Exemples :**
`Compteur`, `Total_Somme`, `Est_Valide`, `Ma_Procedure`

**Points importants pour l'IA :**
* Apprendre les r√®gles de formation des identificateurs valides.
* Distinguer les identificateurs des mots-cl√©s.

 5. Mots-Cl√©s R√©serv√©s

Le langage Z poss√®de un ensemble de mots-cl√©s qui ont une signification sp√©ciale et ne peuvent pas √™tre utilis√©s comme identificateurs.
Voici une liste non exhaustive (√† compl√©ter √† partir de l'index des mots-cl√©s du document `Khawarizm_.pdf`) :

`ACTION`, `ALGORITHME`, `APPEL`, `ARB`, `ARM`, `BOOLEEN`, `BOOLEENS`, `CAR`, `CARACTERE`, `CARACTERES`, `CHAINE`, `CHAINES`, `CONST`, `CREERFILE`, `CREERNOEUD`, `CREERPILE`, `CREER_ARB`, `CREER_ARM`, `CREER_FILE`, `CREER_LISTE`, `DE`, `DEBUT`, `DEFILER`, `DEPILER`, `DES`, `ECRIRE`, `ELEMENT`, `EMPILER`, `ENFILER`, `ENTIER`, `ENTIERS`, `ET`, `FAUX`, `FICHIER`, `FILE`, `FIN`, `FINSI`, `FINTANTQUE`, `FINPOUR`, `FONCTION`, `LIRE`, `LISTE`, `MOD`, `NIL`, `NON`, `OU`, `PILE`, `POUR`, `PROCEDURE` (synonyme d'ACTION), `REEL` (√† v√©rifier si support√©, les documents mentionnent principalement ENTIER), `REPETER`, `RETOURNE` (pourrait √™tre utilis√© avec FONCTION), `SI`, `SINON`, `SOIT`, `SOIENT`, `STRUCT`, `TABLEAU`, `TANTQUE`, `TYPE`, `UN`, `UNE`, `VECTEUR`, `VRAI`.

**Points importants pour l'IA :**
* M√©moriser cette liste pour √©viter les conflits lors de la g√©n√©ration de noms.
* Utiliser ces mots-cl√©s pour comprendre la structure et la s√©mantique du code.

6. Types de Donn√©es

 6.1. Types Scalaires Standards

* **ENTIER**: Pour les nombres entiers (positifs, n√©gatifs ou nuls).
    * Exemple de d√©claration : `Age : ENTIER`
* **BOOLEEN**: Pour les valeurs logiques.
    * Valeurs possibles : `VRAI`, `FAUX`.
    * Exemple de d√©claration : `Trouve : BOOLEEN`
* **CAR**: Pour un caract√®re unique.
    * Les litt√©raux caract√®res sont souvent entour√©s d'apostrophes (ex: `'A'`).
    * Exemple de d√©claration : `Lettre : CAR`
* **CHAINE**: Pour les s√©quences de caract√®res.
    * Les litt√©raux cha√Ænes sont souvent entour√©s de guillemets (ex: `"Bonjour"`).
    * Exemple de d√©claration : `Message : CHAINE`

### 6.2. Types Compos√©s

Le langage Z permet de d√©finir des types plus complexes :

* **Tableaux / Vecteurs**: Collections d'√©l√©ments de m√™me type, accessibles par un ou plusieurs indices.
    * Syntaxe de d√©claration : `Mon_Tableau : TABLEAU [borne_inf..borne_sup] DE Type_Element`
    * Exemple : `Notes : TABLEAU [1..20] DE ENTIER`
    * Les vecteurs peuvent √™tre statiques ou dynamiques (`ALLOC_TAB`, `LIBER_TAB`).

* **Structures (Enregistrements)**: Collections d'√©l√©ments de types potentiellement diff√©rents, appel√©s champs, accessibles par leur nom.
    * Syntaxe de d√©claration de type :
        ```Z
        TYPE
            Nom_Type_Structure = STRUCTURE
                Champ1 : Type1 ;
                Champ2 : Type2 ;
                // ...
            FINSTRUCTURE // ou FIN STRUCT
        ```
    * D√©claration de variable : `Ma_Var : Nom_Type_Structure`
    * Exemple :
        ```Z
        TYPE
            Personne = STRUCTURE
                Nom : CHAINE[30] ; // Cha√Æne de longueur fixe
                Age : ENTIER ;
            FINSTRUCTURE
        SOIENT
            Etudiant : Personne ;
        ```
    * Les structures peuvent √™tre statiques ou dynamiques (`ALLOC_STRUCT`, `LIBER_STRUCT`).

* **Pointeurs**: Utilis√©s pour les structures de donn√©es dynamiques (listes, arbres). Un pointeur contient l'adresse d'une variable.
    * Syntaxe de d√©claration : `Ptr_Var : ^Type_Cible` (la notation exacte peut varier, se r√©f√©rer aux exemples des PDFs).
    * Valeur sp√©ciale : `NIL` (indique que le pointeur ne pointe sur rien).

* **Listes Lin√©aires Cha√Æn√©es**: S√©quences d'√©l√©ments (n≈ìuds) o√π chaque n≈ìud contient une donn√©e et un pointeur vers le n≈ìud suivant (et pr√©c√©dent pour les listes bilat√©rales).
    * Implique la d√©finition d'un type n≈ìud (structure) et l'utilisation de pointeurs.
    * Op√©rations typiques : `CREER_LISTE`, `INSERER`, `SUPPRIMER`, `CHERCHER`.

* **Files d'attente (Queues)**: Structure de type FIFO (Premier Entr√©, Premier Sorti).
    * Op√©rations typiques : `CREER_FILE`, `ENFILER`, `DEFILER`, `FILE_VIDE`.

* **Piles (Stacks)**: Structure de type LIFO (Dernier Entr√©, Premier Sorti).
    * Op√©rations typiques : `CREER_PILE`, `EMPILER`, `DEPILER`, `PILE_VIDE`.

* **Arbres (Binaires, M-aires)**: Structures de donn√©es hi√©rarchiques.
    * Implique la d√©finition d'un type n≈ìud.
    * Op√©rations typiques : `CREER_ARB`, `CREERNOEUD`, `FG` (fils gauche), `FD` (fils droit), `PERE`.

* **Fichiers**: Pour la persistance des donn√©es.
    * D√©claration : `Mon_Fichier : FICHIER DE Type_Element`
    * Op√©rations : `OUVRIR`, `FERMER`, `LIRESEQ`, `ECRIRESEQ`.

* **Types Compos√©s Complexes**: Le langage Z permet des imbrications comme `PILE DE FILES DE LISTES DE ENTIER`.
    * Exemple : `MaStructureComplexe : PILE DE LISTE DE CAR`

**Points importants pour l'IA :**
* Reconna√Ætre les mots-cl√©s de chaque type.
* Comprendre la syntaxe de d√©claration pour chaque type (dimensions pour les tableaux, champs pour les structures, etc.).
* Associer les op√©rations de haut niveau (ex: `EMPILER`) avec le type de donn√©es correspondant (ex: `PILE`).

## 7. D√©clarations

Toutes les entit√©s (constantes, types, variables, modules) doivent √™tre d√©clar√©es avant leur utilisation. Les d√©clarations se font principalement dans la section `SOIENT`.

### 7.1. D√©claration de Constantes

Permet de donner un nom √† une valeur fixe.
Syntaxe : `CONST Nom_Constante = Valeur ;`
Exemple : `CONST PI = 3.14159 ;`
Exemple : `CONST MAX_TAILLE = 100 ;`

### 7.2. D√©claration de Types

Permet de d√©finir de nouveaux types de donn√©es (surtout pour les structures, tableaux, etc.).
Syntaxe :
```Z
TYPE
    Nouveau_Nom_Type = D√©finition_Type ;
    // ... autres d√©finitions de type
```
Exemple (d√©j√† vu pour les structures) :
```Z
TYPE
    Point = STRUCTURE
        X, Y : ENTIER ;
    FINSTRUCTURE
```

### 7.3. D√©claration de Variables

Associe un nom √† un emplacement m√©moire qui peut stocker une valeur d'un type donn√©.
Syntaxe g√©n√©rale : `[SOIT | SOIENT] Liste_Identificateurs <S√©parateur> Type_Donn√©e ;`
* `Liste_Identificateurs`: Un ou plusieurs noms de variables, s√©par√©s par des virgules.
* `<S√©parateur>`: Peut √™tre `:`, `UN`, `UNE`, `DES`. Le choix est souvent stylistique ou pour la lisibilit√©.
* `Type_Donn√©e`: Un type standard ou un type pr√©alablement d√©fini.

Exemples :
`SOIENT I, J, K : ENTIER ;`
`SOIT Nom_Utilisateur UNE CHAINE ;`
`SOIENT Scores DES TABLEAU [1..10] DE ENTIER ;`
`SOIT P1 UN Point ;`

### 7.4. Annonce de Modules (Actions et Fonctions)

Avant de d√©finir une action ou une fonction (si elle n'est pas d√©finie avant son premier appel, ce qui est la norme pour les d√©finitions apr√®s le module principal), elle doit √™tre annonc√©e dans la section `SOIENT` du module qui l'appelle ou globalement.
Syntaxe Annonce Action : `ACTION Nom_Action (Liste_Param√®tres_Formels_Avec_Types) ;`
Syntaxe Annonce Fonction : `FONCTION Nom_Fonction (Liste_Param√®tres_Formels_Avec_Types) : Type_Retour ;`

Exemple :
```Z
SOIENT
    // ... autres d√©clarations
    ACTION Afficher_Message (Msg : CHAINE) ;
    FONCTION Calculer_Somme (A, B : ENTIER) : ENTIER ;
```

**Points importants pour l'IA :**
* Identifier le type de d√©claration (constante, type, variable, module).
* Extraire le nom, le type et la valeur (pour les constantes) ou la structure (pour les types).
* Comprendre la port√©e des d√©clarations (globale si dans `SOIENT` du module principal, locale sinon).

## 8. Expressions

Une expression est une combinaison de valeurs (litt√©raux, constantes, variables), d'op√©rateurs et d'appels de fonctions, qui s'√©value en une unique valeur.

### 8.1. Expressions Arithm√©tiques
Op√©rateurs : `+` (addition), `-` (soustraction, unaire moins), `*` (multiplication), `/` (division r√©elle), `DIV` (division enti√®re), `MOD` (modulo).
Priorit√© des op√©rateurs : `*`, `/`, `DIV`, `MOD` ont une priorit√© plus √©lev√©e que `+`, `-`. Les parenth√®ses `()` peuvent √™tre utilis√©es pour forcer l'ordre d'√©valuation.
Exemple : `(A + B) * C / 2`

### 8.2. Expressions Logiques (Bool√©ennes)
Op√©rateurs : `ET` (ET logique), `OU` (OU logique), `NON` (NON logique).
Valeurs : `VRAI`, `FAUX`.
Exemple : `(Age >= 18) ET (Est_Etudiant OU A_Reduction)`
Exemple : `NON Trouve`

### 8.3. Expressions Relationnelles (de Comparaison)
Op√©rateurs : `=`, `<>` (ou `#` pour diff√©rent), `<`, `<=`, `>`, `>=`.
R√©sultat : Toujours une valeur bool√©enne (`VRAI` ou `FAUX`).
Exemple : `X > Y`, `Nom = "Test"`

### 8.4. Expressions sur Cha√Ænes de Caract√®res
Op√©rateur : `+` (concat√©nation).
Exemple : `"Bonjour" + " " + Nom_Utilisateur`

### 8.5. Acc√®s aux √âl√©ments de Types Compos√©s
* Tableaux : `Nom_Tableau[Index]`
    Exemple : `Notes[I]`
* Structures : `Nom_Variable_Structure.Nom_Champ`
    Exemple : `Etudiant.Age`
* Pointeurs (d√©r√©f√©rencement) : `Nom_Pointeur^` (pour acc√©der √† la valeur point√©e) ou `Nom_Pointeur^.Champ` si le pointeur pointe sur une structure. La notation exacte peut varier (ex: `INFO(P)` pour le contenu d'un n≈ìud point√© par P dans une liste). Se r√©f√©rer aux op√©rations sp√©cifiques des structures de donn√©es dans les PDFs.

### 8.6. Appels de Fonctions
Une fonction, lorsqu'elle est appel√©e dans une expression, retourne une valeur qui est utilis√©e dans le calcul de l'expression.
Syntaxe : `Nom_Fonction (Param√®tre_Actuel_1, Param√®tre_Actuel_2, ...)`
Exemple : `Resultat := Calculer_Somme(N1, N2) + 10`

**Points importants pour l'IA :**
* Parser correctement les expressions en respectant la priorit√© des op√©rateurs.
* Identifier le type r√©sultant d'une expression.
* G√©rer les appels de fonction et l'acc√®s aux √©l√©ments de structures de donn√©es.

## 9. Instructions (Actions √âl√©mentaires et Structures de Contr√¥le)

Les instructions d√©crivent les op√©rations √† effectuer.

### 9.1. Affectation
Attribue la valeur d'une expression √† une variable.
Syntaxe : `Nom_Variable := Expression ;`
Le type de `Expression` doit √™tre compatible avec le type de `Nom_Variable`.
Exemples :
`Compteur := Compteur + 1 ;`
`Message_Bienvenue := "Bonjour !" ;`
`Est_Majeur := Age >= 18 ;`
`Mon_Tableau[Indice] := Valeur ;`
`Mon_Record.Champ := Autre_Valeur ;`

L'affectation globale est permise pour les types compos√©s (ex: copier une structure enti√®re dans une autre de m√™me type).

### 9.2. Lecture (Entr√©e)
Permet d'obtenir des donn√©es depuis une source d'entr√©e standard (g√©n√©ralement le clavier) et de les stocker dans des variables.
Syntaxe : `LIRE ( Variable_1, Variable_2, ... ) ;`
Exemple : `LIRE ( Age, Nom ) ;`

### 9.3. √âcriture (Sortie)
Permet d'afficher les valeurs d'expressions ou des messages sur une sortie standard (g√©n√©ralement l'√©cran).
Syntaxe : `ECRIRE ( Expression_1, Expression_2, ... ) ;`
Les expressions peuvent √™tre des litt√©raux, des variables, ou des calculs plus complexes.
Exemple : `ECRIRE ( "Le r√©sultat est : ", Somme / Nombre_Elements ) ;`
Exemple : `ECRIRE ( "Bonjour ", Nom_Utilisateur, " !" ) ;`

### 9.4. Structures de Contr√¥le

#### 9.4.1. Conditionnelle (SI ... SINON ... FINSI)
Ex√©cute des blocs d'instructions en fonction de la valeur d'une condition bool√©enne.
* Forme simple :
    ```Z
    SI Condition_Booleenne [ALORS | :] // ALORS ou : est optionnel, : est fr√©quent
        // Bloc d'instructions si la condition est VRAI
    FINSI
    ```
* Forme avec alternative :
    ```Z
    SI Condition_Booleenne [ALORS | :]
        // Bloc d'instructions si la condition est VRAI
    SINON
        // Bloc d'instructions si la condition est FAUX
    FINSI
    ```
* Imbrication :
    ```Z
    SI Condition_1 :
        // ...
    SINON
        SI Condition_2 :
            // ...
        SINON
            // ...
        FINSI
    FINSI
    ```
Exemple :
```Z
SI Note >= 10 :
    ECRIRE ( "Admis" ) ;
SINON
    ECRIRE ( "Ajourn√©" ) ;
FINSI
```

#### 9.4.2. Boucle TANTQUE (Tant que ... Faire)
R√©p√®te un bloc d'instructions tant qu'une condition bool√©enne reste vraie. La condition est test√©e avant chaque it√©ration.
Syntaxe :
```Z
TANTQUE Condition_Booleenne [FAIRE | :] // FAIRE ou : est optionnel
    // Bloc d'instructions √† r√©p√©ter
FINTANTQUE // ou FTQ
```
Exemple :
```Z
SOIENT I : ENTIER ;
I := 1 ;
TANTQUE I <= 10 :
    ECRIRE ( I ) ;
    I := I + 1 ;
FINTANTQUE
```

#### 9.4.3. Boucle POUR (Pour ... De ... √Ä ...)
R√©p√®te un bloc d'instructions un nombre d√©termin√© de fois, en utilisant une variable compteur.
Syntaxe :
```Z
POUR Variable_Compteur := Valeur_Initiale , Valeur_Finale [, Pas] [FAIRE | :] // Pas est optionnel, d√©faut 1
    // Bloc d'instructions √† r√©p√©ter
FINPOUR // ou FPOUR
```
* `Variable_Compteur` : Doit √™tre d'un type ordinal (g√©n√©ralement ENTIER).
* `Valeur_Initiale`, `Valeur_Finale` : Expressions √©valuant au type du compteur.
* `Pas` (optionnel) : Expression enti√®re. Si positif, le compteur est incr√©ment√©. Si n√©gatif, il est d√©cr√©ment√©. Si omis, le pas est de `1`.

Exemple (incr√©mentation) :
```Z
POUR I := 1 , 5 : // Pas de 1 par d√©faut
    ECRIRE ( "It√©ration num√©ro : ", I ) ;
FINPOUR
```
Exemple (d√©cr√©mentation avec pas explicite) :
```Z
POUR J := 10 , 1 , -2 :
    ECRIRE ( J ) ;
FINPOUR // Affichera 10, 8, 6, 4, 2
```

#### 9.4.4. Boucle REPETER ... JUSQU'A (√Ä v√©rifier si pr√©sent dans les documents Z fournis)
R√©p√®te un bloc d'instructions jusqu'√† ce qu'une condition devienne vraie. Le bloc est ex√©cut√© au moins une fois car la condition est test√©e apr√®s l'it√©ration.
Syntaxe (typique, √† confirmer pour Z) :
```Z
REPETER
    // Bloc d'instructions
JUSQU'A Condition_Booleenne
```
*Note : Les documents fournis se concentrent sur `TANTQUE` et `POUR`. Si `REPETER...JUSQU'A` est support√©, sa syntaxe exacte doit √™tre v√©rifi√©e.*

**Points importants pour l'IA :**
* Identifier chaque type d'instruction.
* Pour les affectations, valider la compatibilit√© des types.
* Pour les structures de contr√¥le, identifier la condition et les blocs d'instructions associ√©s.
* Comprendre la s√©mantique de chaque boucle (condition de test, modification du compteur).

## 10. Modules : Actions et Fonctions

Les modules permettent de structurer le code, de le r√©utiliser et de le rendre plus lisible.

### 10.1. Actions (Proc√©dures)
Un bloc d'instructions nomm√© qui peut √™tre appel√© pour effectuer une t√¢che sp√©cifique. Ne retourne pas de valeur directement (mais peut modifier des variables pass√©es en param√®tre ou des variables globales).

* **Annonce (D√©claration anticip√©e)**: (Vue dans la section D√©clarations)
    `ACTION Nom_Action (P1:Type1 ; P2:Type2 ; ... ) ;`
    Les param√®tres dans l'annonce incluent leurs types.

* **D√©finition**:
    ```Z
    ACTION Nom_Action (P_formel_1 [:Type1] ; P_formel_2 [:Type2] ; ... ) // Types optionnels ici si d√©j√† dans l'annonce, mais bon pour la clart√©
        SOIENT
            // D√©clarations locales (variables, constantes, types sp√©cifiques √† l'action)
        DEBUT
            // Corps de l'action (instructions)
        FIN
    ```
    Les param√®tres formels (`P_formel_1`, etc.) sont des placeholders pour les valeurs qui seront pass√©es lors de l'appel.
    Le passage de param√®tres en Z est **par r√©f√©rence** (ou adresse) par d√©faut. Cela signifie que si l'action modifie un param√®tre, la variable originale pass√©e lors de l'appel est modifi√©e. (Il est important de v√©rifier s'il existe un m√©canisme de passage par valeur explicitement).

* **Appel**:
    `APPEL Nom_Action (Param_Actuel_1, Param_Actuel_2, ... ) ;`
    Ou plus simplement : `Nom_Action (Param_Actuel_1, Param_Actuel_2, ... ) ;` (L'utilisation de `APPEL` est souvent une convention plus ancienne ou pour la clart√©).
    Les param√®tres actuels sont les valeurs ou variables r√©elles pass√©es √† l'action.

Exemple :
```Z
SOIENT
    ACTION Afficher_Somme (A:ENTIER ; B:ENTIER) ; // Annonce

// ... dans le module principal ...
DEBUT
    // ...
    APPEL Afficher_Somme (Nombre1, Nombre2) ;
    // ...
FIN

// D√©finition de l'action
ACTION Afficher_Somme (A:ENTIER ; B:ENTIER)
    SOIENT
        Somme_Locale : ENTIER ;
    DEBUT
        Somme_Locale := A + B ;
        ECRIRE ( "La somme est : ", Somme_Locale ) ;
    FIN
```

### 10.2. Fonctions
Similaires aux actions, mais elles **retournent une valeur** d'un type sp√©cifi√©.

* **Annonce (D√©claration anticip√©e)**: (Vue dans la section D√©clarations)
    `FONCTION Nom_Fonction (P1:Type1 ; P2:Type2 ; ... ) : Type_Retour ;`

* **D√©finition**:
    ```Z
    FONCTION Nom_Fonction (P_formel_1 [:Type1] ; P_formel_2 [:Type2] ; ... ) : Type_Retour
        SOIENT
            // D√©clarations locales
        DEBUT
            // Corps de la fonction (instructions)
            // ...
            Nom_Fonction := Expression_De_Retour ; // Instruction cruciale pour retourner la valeur
            // ...
        FIN
    ```
    L'instruction `Nom_Fonction := Expression_De_Retour ;` assigne la valeur √† retourner au nom de la fonction elle-m√™me. C'est ainsi que la valeur est renvoy√©e √† l'appelant.
    Le passage de param√®tres est √©galement par r√©f√©rence par d√©faut.

* **Appel**:
    Une fonction est appel√©e dans une expression, l√† o√π une valeur de son type de retour est attendue.
    `Variable_Resultat := Nom_Fonction (Param_Actuel_1, Param_Actuel_2, ... ) ;`
    `ECRIRE ( "R√©sultat : ", Nom_Fonction(X, Y) ) ;`



''')

# Create document chain
document_chain = create_stuff_documents_chain(llm, prompt)

# Create retrieval chain
retriever = db.as_retriever(
    search_kwargs={"k": 6}  # Retrieve top 4 most relevant documents
)

from langchain.chains import create_retrieval_chain

retriever_chain = create_retrieval_chain(retriever, document_chain)

# Example usage
def query_system(question):
    result = retriever_chain.invoke({'input': question})
    return result['answer']

# Example query
from pprint import pprint

# Example query
query = "give a program using Z language to insert a list and calculate the sum of its elements and display the elements of the list, wihout using fucntions just global code"
response = query_system(query)

groqrr= response
print( response)
from IPython.display import Markdown, display

from pprint import pprint
display(Markdown(response))

# To load it back later:
# loaded_db = FAISS.load_local(save_directory, embeddings)

# Now let's modify to use GROQ API instead of Ollama
from IPython.display import Markdown, display
from pprint import pprint
from langchain.chains import create_retrieval_chain
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain_groq import ChatGroq  # Import the GROQ chat model
from langchain_core.prompts import ChatPromptTemplate
import os

# Set your GROQ API key - make sure to keep this secure!
# Replace with your actual API key
os.environ["GROQ_API_KEY"] = "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"

# Initialize the GROQ LLM - replaced Ollama with GROQ
llm = ChatGroq(
    # model="llama3-70b-8192",  # You can choose "mixtral-8x7b-32768" or other models
    # You can choose "mixtral-8x7b-32768" or other models
    model='llama-3.3-70b-versatile',
    temperature=0,
    max_tokens=32768,  # Control response length
)

# The prompt template remains the same
prompt = ChatPromptTemplate.from_template(r'''[Contexte] {context}
[Question] {input}
#
1.  STANDARD SCALAR TYPES (from Page 13, 17):
    Four standard scalar types are authorized:
    *   `ENTIER` (Integer)
    *   `BOOLEEN` (Boolean)
    *   `CARACTERE` (Character)
    *   `CHAINE` (String)

2.  SCALAR VARIABLE DECLARATION (from Page 17):
    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> <Type_Standard>`

    *   `SOIT` / `SOIENT`: Optional keywords (conventionally used).
    *   `<Liste_Identificateurs>`: A list of identifiers separated by commas (e.g., `X, Y, Z`).
    *   `<Separateur_Type>`: Can be one of `:`, `UN`, `UNE`, `DES`.
    *   `<Type_Standard>`: One of `ENTIER`, `BOOLEEN`, `CARACTERE`, `CHAINE` (or `ENTIERS`, `BOOLEENS`, `CHAINES` if plural form of separator is used, although the document isn't perfectly consistent here, `BOOLEENS` is shown with `:`)

    Examples (from Page 17):
    ```
    A, B, Trouv : BOOLEENS ;
    X, Y, Z DES BOOLEENS ;
    A : ENTIERS ;  // Assuming ENTIERS is a valid plural like BOOLEENS
    A : ENTIER ;   // More likely based on standard types
    X, Y, Z DES CHAINES ;
    ```

3.  POINTERS (Objets "Pointeurs") (from Page 17, 18):
    Used for manipulating data structures.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> POINTEUR VERS [<Separateur_Cible>] [DE <Type_Compose_Element> DE <Type_Compose_Element> ...] [DE <Type_Scalaire_Ou_Structure_Simple>]`

    *   `<Separateur_Cible>`: Optional, from `UN, UNE, DES`.
    *   `<Type_Compose_Element>`: One of `VECTEUR`, `PILE`, `LISTE`, `FILE`, `ARB` (binary tree), `LISTEBI` (bidirectional list), `ARM` (m-ary tree).
        (Note: `PILE` is listed twice in the OCR on page 18, likely a typo.)
    *   `<Type_Scalaire_Ou_Structure_Simple>`: A scalar type or a simple structure type if it's the final element type.

    Remark (Page 18):
    `SOIT L UNE LISTE` is equivalent to `SOIT L UN POINTEUR VERS UNE LISTE`. This implies that direct data structure type declarations are implicitly pointer types.

    Examples (from Page 18):
    ```
    P1 : POINTEUR VERS LISTE DE PILE ;
    P2, P3 DES POINTEURS VERS DES ARB ; // Corrected P2, P2 to P2, P3 for clarity
    ```

4.  STRUCTURES (from Page 20):
    A heterogeneous collection of elements. Can be simple (only scalars) or complex (scalars and/or 1D vectors). Can be static or dynamic.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> [STRUCTURE] ( <Type1>, <Type2>, ... ) [DYNAMIQUE]`

    *   `STRUCTURE`: Optional keyword.
    *   `<TypeI>`: Can be a scalar type or a 1D vector (e.g., `VECTEUR(5) DE CHAINE`).
    *   `DYNAMIQUE`: Keyword for dynamic allocation.

    Examples (from Page 20):
    ```
    S1 : (ENTIER, CHAINE) ;
    S2 UNE STRUCTURE ( CHAINE, ENTIER, BOOLEEN) ;
    S3 UN (ENTIER, VECTEUR(5) DE CHAINE) DYNAMIQUE ;
    ```

5.  TABLEAUX (Arrays/Vectors) (from Page 20):
    A homogeneous collection of elements. Can be simple (scalar elements) or complex (simple structure elements). Can be static or dynamic.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> VECTEUR(<Dim1>[, <Dim2>, ...]) [DE <Type_Compose_Element> DE ... ] DE <Type_Element_Final> [DYNAMIQUE]`

    *   `VECTEUR(<Dim1>[, <Dim2>, ...])`: Specifies dimensions. `TABLEAU` can be used instead of `VECTEUR`.
    *   `DE <Type_Compose_Element>`: For arrays of complex types like `PILE`, `LISTE`.
    *   `DE <Type_Element_Final>`: The base type of elements (scalar or simple structure).
    *   `DYNAMIQUE`: Keyword for dynamic allocation.

    Examples (from Page 20):
    ```
    V1 UN TABLEAU (5) DYNAMIQUE ;  // Elements are of default type or needs further spec. based on context
    V2, V3 DES VECTEURS (3, 8) DE CHAINES ; // A 2D array of strings
    ```

6.  LISTES LINEAIRES CHAINEES (Singly Linked Lists) (from Page 21):
    Dynamically allocated chain of nodes. Each node has `Valeur` and `Adresse` (next).

    General Form (implicit pointer as per page 18 remark):
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> LISTE [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 21):
    ```
    L1 UNE LISTE DE (CHAINE, ENTIER) ; // A list where elements are structures of (CHAINE, ENTIER)
    L2 UNE LISTE DE PILE DE CHAINE ; // A list of stacks of strings
    L3 UNE LISTE DE CHAINES ; // A list of strings
    ```

7.  LISTES LINEAIRES CHAINEES BILATERALES (Doubly Linked Lists) (from Page 21):
    Nodes have `Valeur`, `adresse gauche` (previous), `adresse droite` (next).

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> LISTEBI [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 21):
    ```
    Lb1 UNE LISTEBI DE (CHAINE, ENTIER) ;
    Lb2 UNE LISTEBI DE PILE DE CHAINE ;
    Lb3 UNE LISTEBI DE CHAINES ;
    ```

8.  FILES D'ATTENTE (Queues - FIFO) (from Page 21):
    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> FILE [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 22):
    ```
    F1 UNE FILE DE (CHAINE, ENTIER) ;
    F2 UNE FILE DE PILE DE CHAINE ;
    F3 UNE FILE DE CHAINES ;
    ```

9.  PILES (Stacks - LIFO) (from Page 22):
    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> PILE [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 22):
    ```
    P1 UNE PILE DE (CHAINE, ENTIER) ;
    P2 UNE PILE DE PILE DE CHAINE ;
    P3 UNE PILE DE CHAINES ;
    ```

10. ARBRES DE RECHERCHE BINAIRE (Binary Search Trees) (from Page 22):
    Node structure: `(left_child, Value, right_child)`.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> ARB [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 23):
    ```
    A1 UN ARB DE (CHAINE, ENTIER) ;
    A2 UN ARB DE PILE DE CHAINE ;
    A3 UN ARB DE CHAINES ;
    ```

11. ARBRES DE RECHERCHE M-AIRE (M-ary Search Trees) (from Page 23):
    Node of order `p` contains `(p-1)` informations and `p` children.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> ARM (<degre>) [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    *   `<degre>`: The order of the m-ary tree.

    Examples (from Page 23):
    ```
    M1 UN ARM(4) DE (CHAINE, ENTIER) ;
    M2 UN ARM(2) DE PILE DE CHAINE ; // An m-ary tree of order 2 is a binary tree
    M3 UN ARM(3) DE CHAINES ;
    ```

12. FICHIERS (Files) (from Page 23, 24):
    Set of records, typically on disk. Involves a mandatory header part for file structure design.
    A file definition has 3 parts:
    *   `FICHIER DE type_element`: Nature of file elements (scalar, 1D vector, or complex structure).
    *   `BUFFER <Liste_Tampons>`: Buffer variables for read/write operations.
    *   `ENTETE (<Type_Carac1>, <Type_Carac2>, ...)`: Optional. Defines file characteristics.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> FICHIER DE <Type_Element_Fichier> BUFFER <Liste_Variables_Tampon> [ENTETE (<Type_Carac1>, <Type_Carac2>, ...)]`

    Examples (from Page 24):
    ```
    F1 UN FICHIER DE CHAINES BUFFER V1, V2 ;
    F2 UN FICHIER DE VECTEUR(5) DE ENTIER BUFFER V ;
    F3 UN FICHIER DE (ENTIER, VECTEUR(3) DE CAR) BUFFER V ENTETE(ENTIER, ENTIER) ;
    F4 UN FICHIER DE CAR BUFFER V ENTETE (ENTIER, CHAINE, BOOLEEN) ;
    ```

13. DECLARING ABSTRACT MACHINES (from Page 25):
    Implicitly, declaring a variable of a data structure type (like LISTE, PILE, etc.) also makes the operations of its abstract machine available for that variable.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> <Nom_Machine_Abstraite_Ou_Type_DS>`

    Examples (from Page 25):
    ```
    L1, L2 DES LISTES ;
    F UNE FILE ;
    V1 UN VECTEUR(10, 60) ; // Assuming default element type or it implies a simple scalar
    Y UNE LISTE DE PILES DE VECTEUR(5) ;
    ```

================================================================================
III. EXPRESSIONS AND OPERATORS (from Page 18)
================================================================================

1.  ARITHMETIC EXPRESSIONS:
    Operators: `+`, `-`, `/`, `*`

2.  LOGICAL EXPRESSIONS:
    Operators: `ET`, `OU`, `NON`

3.  STRING EXPRESSIONS:
    Operator: `+` (concatenation)

4.  RELATIONAL EXPRESSIONS:
    Operators: `<`, `<=`, `>`, `>=`, `=`, `<>` (or `#` for not equal)

5.  CONSTANTS:
    *   Logical Constants: `VRAI`, `FAUX`
    *   Pointer Constant: `NIL` (used for uninitialized or end-of-list pointers)

    Examples (from Page 18):
    ```
    B+C/F
    NON Trouv
    (X # 5) ET NON TROUV
    F(X) <> 5
    P = NIL
    ```

================================================================================
IV. ACTIONS ELEMENTAIRES (from Page 15)
================================================================================

1.  AFFECTATION (Assignment):
    Assigns the value of an expression to a variable.
    Syntax: `V := Exp`

    Example:
    ```
    X := 10 ;
    Trouv := FAUX ;
    NomFonction := X + Y ; // Inside a function to set its return value
    ```

2.  LECTURE (Input):
    Reads data into variables.
    Syntax: `LIRE (V1, V2, ...)`

    Example:
    ```
    LIRE (Age, NomUtilisateur) ;
    ```

3.  ECRITURE (Output):
    Outputs the value of expressions.
    Syntax: `ECRIRE (Exp1, Exp2, ...)`
    (Can output entire expressions or character strings)

    Example:
    ```
    ECRIRE ("Le r√©sultat est : ", Resultat, " unit√©s.") ;
    ECRIRE (Tableau[i]) ;
    ```

================================================================================
V. STRUCTURES DE CONTROLE (from Page 14, 15)
================================================================================

1.  LA BOUCLE TANTQUE (While Loop):
    Syntax:
    ```
    TANTQUE <Expression_Booleenne> [:]
        <Instructions>
    FINTANTQUE
    ```
    *   `[:]`: Optional colon (purpose not explicitly defined, might be for style or indenter).
    *   `<Expression_Booleenne>`: The loop condition.
    *   `<Instructions>`: Statements executed as long as the condition is `VRAI`.

2.  LA BOUCLE POUR (For Loop):
    Syntax:
    ```
    POUR <Variable_Compteur> := <Expression_Debut>, <Expression_Fin> [,<Expression_Pas>] [:]
        <Instructions>
    FINPOUR
    ```
    *   `<Variable_Compteur>`: Loop counter variable.
    *   `<Expression_Debut>`: Initial value of the counter.
    *   `<Expression_Fin>`: Final value for the counter (loop continues while counter <= Fin).
    *   `<Expression_Pas>`: Optional. Increment step for the counter. Default is 1.
    *   `[:]`: Optional colon.

3.  LA CONDITIONNELLE (If Statement - Simple):
    Syntax:
    ```
    SI <Expression_Booleenne> [:]
        <Instructions>
    FINSI
    ```
    *   `[:]`: Optional colon.
    *   `<Instructions>`: Executed if `<Expression_Booleenne>` is `VRAI`.

4.  L'ALTERNATIVE (If-Else Statement):
    Syntax:
    ```
    SI <Expression_Booleenne> [:]
        <Instructions_Si_Vrai>
    SINON
        <Instructions_Si_Faux>
    FINSI
    ```
    *   `[:]`: Optional colon.

================================================================================
VI. MODULES: ACTIONS ET FONCTIONS
================================================================================

1.  ACTION COMPOSEE (Procedure) (from Page 16):
    A named block of code performing a specific task. Parameters are passed by "reference" (implying input parameters are not protected from modification within the action).
    An action must be announced (forward declared) in the main module.

    Definition Syntax:
    ```
    ACTION <Nom_Action> ( <Param1>, <Param2>, ..., <ParamN> )
        <D√©clarations_Objets_Locaux_Et_Param√®tres>
    DEBUT
        <Instructions>
    FIN
    ```

    Appel (Call) Syntax (from Page 17):
    `APPEL <Nom_Action> ( <Param√®tres_R√©els> )`

    Example Annonce (Conceptual):
    ```
    SOIENT
        UneAction : ACTION (p1:ENTIER, p2:CHAINE); // Annonce format not explicitly given, inferred
    ...
    ```

2.  FONCTION (Function) (from Page 17):
    A named block of code that computes and returns a value. Parameters are passed by "reference".
    A function must be announced in the main module, specifying its return type.
    The return value is set by assigning to the function's name within its body (`Nom := Expression`).

    Definition Syntax:
    ```
    FONCTION <Nom_Fonction> ( <Param1>, <Param2>, ..., <ParamN> ) : <Type_Retour>
        <D√©clarations_Objets_Locaux_Et_Param√®tres>
    DEBUT
        <Instructions>
        ...
        <Nom_Fonction> := <Expression_Resultat> ;
        ...
    FIN
    ```

    Appel (Call) Syntax:
    A function is called by using its name in an expression.
    Example: `Resultat := MaFonction(X, Y) + 5 ;`

    Example Annonce (from page 8, 18):
    ```
    SOIENT
        Rech, Tous : FONCTION (BOOLEEN);
    ...
    FONCTION Rech (L, Val) : BOOLEEN // L, Val types declared inside function's SOIENT
    ...
    ```

================================================================================
VII. FONCTIONS PREDEFINIES ET OPERATIONS DE HAUT NIVEAU
================================================================================

1.  FONCTIONS STANDARDS (from Page 16):
    *   `MOD (A, B)`: Remainder of integer division A by B.
    *   `MAX (A, B)`: Maximum of A and B.
    *   `MIN (A, B)`: Minimum of A and B.
    *   `EXP (A, B)`: A raised to the power of B (A exposant B).

2.  FONCTIONS DE GENERATION ALEATOIRE (Random Generation) (from Page 13, 16):
    *   `ALEACHAINE (N)`: Returns a random string of N characters (uppercase and lowercase alphabet).
    *   `ALEANOMBRE (N)`: Returns a random integer between 0 and N. (Page 16 has `ALEAENTIER`, page 13 `ALEANOMBRE`. `ALEANOMBRE` seems more consistent with `ALEACHAINE`).

3.  FONCTIONS SUR CHAINES DE CARACTERES (String Functions) (from Page 13, 16):
    *   `LONGCHAINE (C)`: Returns the length of string C.
    *   `CARACT (C, I)`: Returns the I-th character of string C.

4.  OPERATIONS DE HAUT NIVEAU (High-Level Operations for Data Structures) (from Page 15):
    These allow filling/initializing a data structure from a set of expressions.
    The expressions `Exp1, Exp2, ...` are scalar or simple structures.
    The list of values is enclosed in `[...]`.

    *   `INIT_VECT ( T, [<Exp1>, <Exp2>, ...] )`
        Initializes vector T.
    *   `INIT_STRUCT ( S, [<Exp1>, <Exp2>, ...] )`
        Initializes structure S.
    *   `CREER_LISTE ( L, [<Exp1>, <Exp2>, ...] )`
        Creates a singly linked list L with given values in order.
        Example: `CREER_LISTE (L, [12, 34, I, I+J, 45])`
    *   `CREER_LISTEBI ( LB, [<Exp1>, <Exp2>, ...] )`
        Creates a doubly linked list LB.
    *   `CREER_ARB ( A, [<Exp1>, <Exp2>, ...] )`
        Creates a binary search tree A. (Insertion order matters).
    *   `CREER_ARM ( M, [<Exp1>, <Exp2>, ...] )`
        Creates an m-ary tree M.
    *   `CREER_FILE ( F, [<Exp1>, <Exp2>, ...] )`
        Creates a queue F.
    *   `CREER_PILE ( P, [<Exp1>, <Exp2>, ...] )`
        Creates a stack P.

================================================================================
VIII. OPERATIONS DES MACHINES ABSTRAITES (from Pages 25-30)
================================================================================

These operations are used to manipulate instances of data structures.

1.  MACHINE ABSTRAITE SUR LES VECTEURS (Vectors/Arrays):
    *   `ELEMENT ( T[i, j, ...] )`: Accesses element at `T[i,j,...]`. Returns the element.
    *   `AFF_ELEMENT ( T[I, J, ...], Val )`: Assigns `Val` to element `T[I,J,...]`.
    *   `ALLOC_TAB ( T )`: Allocates memory for a dynamically declared array T. Address returned in T.
    *   `LIBER_TAB ( T )`: Frees memory pointed to by T.

2.  MACHINE ABSTRAITE SUR LES STRUCTURES (Structures):
    *   `STRUCT ( S, i )`: Accesses the i-th field of structure S. Returns the field's value.
    *   `AFF_STRUCT ( S, i, Exp )`: Assigns `Exp` to the i-th field of structure S.
    *   `ALLOC_STRUCT ( S )`: Allocates memory for a dynamically declared structure S. Address returned in S.
    *   `LIBER_STRUCT ( S )`: Frees memory pointed to by S.

3.  MACHINE ABSTRAITE SUR LES LISTES LINEAIRES CHAINEES (Singly Linked Lists):
    *   `ALLOUER ( P )`: Creates a new node and returns its address in P.
    *   `LIBERER ( P )`: Frees the node at address P.
    *   `SUIVANT ( P )`: Accesses the 'Adresse' (next pointer) field of the node P. Returns pointer.
    *   `VALEUR ( P )`: Accesses the 'Valeur' (data) field of the node P. Returns value.
    *   `AFF_ADR ( P, Q )`: Assigns address Q to the 'Adresse' (next pointer) field of node P. (P^.Suiv := Q).
    *   `AFF_VAL ( P, Val )`: Assigns `Val` to the 'Valeur' (data) field of node P. (P^.Val := Val).

4.  MACHINE ABSTRAITE SUR LES LISTES BIDIRECTIONNELLES (Doubly Linked Lists):
    *   `ALLOUER ( P )`: Creates a new node, returns address in P.
    *   `LIBERER ( P )`: Frees node at address P.
    *   `SUIVANT ( P )`: Accesses 'Adresse droite' (next pointer). Returns pointer.
    *   `PRECEDENT ( P )`: Accesses 'Adresse gauche' (previous pointer). Returns pointer.
    *   `VALEUR ( P )`: Accesses 'Valeur' (data) field. Returns value.
    *   `AFF_ADRD ( P, Q )`: Assigns Q to 'Adresse droite' of P (P^.Suiv := Q).
    *   `AFF_ADRG ( P, Q )`: Assigns Q to 'Adresse gauche' of P (P^.Prec := Q).
    *   `AFF_VAL ( P, Val )`: Assigns `Val` to 'Valeur' of P.

5.  MACHINE ABSTRAITE SUR LES FILES D'ATTENTE (Queues):
    *   `CREERFILE ( F )`: Creates an empty queue F.
    *   `FILEVIDE ( F )`: Tests if queue F is empty. Returns BOOLEEN.
    *   `ENFILER ( F, Val )`: Adds (enqueues) `Val` to the end of queue F.
    *   `DEFILER ( F, Var_Pour_Val )`: Removes (dequeues) value from front of F into `Var_Pour_Val`.

6.  MACHINE ABSTRAITE SUR LES PILES (Stacks):
    *   `CREERPILE ( P )`: Creates an empty stack P.
    *   `PILEVIDE ( P )`: Tests if stack P is empty. Returns BOOLEEN.
    *   `EMPILER ( P, Val )`: Pushes `Val` onto the top of stack P.
    *   `DEPILER ( P, Var_Pour_Val )`: Pops value from top of P into `Var_Pour_Val`.

7.  MACHINE ABSTRAITE SUR LES ARBRES DE RECHERCHE BINAIRE:
    *   `CREERNOEUD ( Val )`: Creates a new tree node with `Val` as info, children are NIL. Returns node address.
    *   `LIBERERNOEUD ( P )`: Frees node P.
    *   `FG ( P )`: Accesses left child (Fils Gauche) of node P. Returns pointer.
    *   `FD ( P )`: Accesses right child (Fils Droit) of node P. Returns pointer.
    *   `PERE ( P )`: Accesses parent of node P. Returns pointer.
    *   `INFO ( P )`: Accesses information/data field of node P. Returns value.
    *   `AFF_FG ( P, Q )`: Sets left child of P to Q.
    *   `AFF_FD ( P, Q )`: Sets right child of P to Q.
    *   `AFF_PERE ( P, Q )`: Sets parent of P to Q.
    *   `AFF_INFO ( P, Val )`: Sets information/data field of P to `Val`.

8.  MACHINE ABSTRAITE SUR LES ARBRES DE RECHERCHE M-AIRE:
    *   `CREERNOEUD ( Val )`: Creates a new tree node with `Val`. Returns node address. (Assumes `Val` might be the first info for m-ary or a general value for leaf).
    *   `LIBERERNOEUD ( P )`: Frees node P.
    *   `FILS ( P, I )`: Accesses the I-th child of node P. Returns pointer.
    *   `PERE ( P )`: Accesses parent of node P. Returns pointer.
    *   `INFOR ( P, I )`: Accesses the I-th information field of node P. Returns value.
    *   `AFF_FILS ( P, I, Q )`: Sets the I-th child of P to Q.
    *   `AFF_PERE ( P, Q )`: Sets parent of P to Q.
    *   `AFF_INFOR ( P, I, Val )`: Sets the I-th information field of P to `Val`.

9.  MACHINE ABSTRAITE SUR LES FICHIERS (Files):
    *   `OUVRIR ( Fl, Fp, Mode )`: Opens logical file `Fl`, associates with physical file `Fp`. `Mode` is 'N' (new) or 'A' (append/ancient).
    *   `FERMER ( Fl )`: Closes logical file `Fl`.
    *   `LIRESEQ ( Fl, V )`: Reads current block/record from `Fl` into buffer variable `V`.
    *   `ECRIRESEQ ( Fl, V )`: Writes content of buffer `V` to current position in `Fl`.
    *   `LIREDIR ( Fl, V, N )`: Reads N-th block/record from `Fl` into buffer `V`.
    *   `ECRIREDIR ( Fl, V, N )`: Writes content of buffer `V` to N-th position in `Fl`.
    *   `RAJOUTER ( Fl, V )`: Appends content of buffer `V` to the end of `Fl`.
    *   `FINFICH ( Fl )`: Predicate, true if end-of-file for `Fl` is reached, false otherwise.
    *   `ALLOC_BLOC ( Fl )`: Provides a block/article in the file `Fl` where one can write (typically returns index/offset for direct access or implies next available for sequential).
    *   `ENTETE ( Fl, I )`: Retrieves the I-th characteristic from the header of file `Fl`.
    *   `AFF_ENTETE ( Fl, I, Exp )`: Sets the I-th characteristic in the header of file `Fl` to `Exp`.

================================================================================
IX. EXAMPLES OF Z-ALGORITHMS (Illustrative fragments from document)
================================================================================

Example from Page 8 (List inclusion check):
```
SOIENT
    L1, L2 DES LISTES ;
    Rech, Tous : FONCTION ( BOOLEEN ) ;
DEBUT
    CREER_LISTE (L1, [2,5,9,8,3,6]) ;
    CREER_LISTE (L2, [12,5,19,8,3,6,2,9]) ;
    ECRIRE ( Tous (L1, L2) )
FIN

{{Recherche d'une valeur dans une liste lin√©aire cha√Æn√©e}}
FONCTION Rech (L, Val) : BOOLEEN
SOIENT
    L UNE LISTE ;
    Val UN ENTIER ;
DEBUT
    SI L = NIL
        Rech := FAUX
    SINON
        SI VALEUR ( L ) = Val
            Rech := VRAI
        SINON
            Rech := Rech ( SUIVANT ( L ), Val)
        FSI
    FSI
FIN

D√©termine si tous les √©l√©ments de L1 sont dans L2 - from page 9, adapted
FONCTION Tous ( L1, L2 ) : BOOLEEN
SOIENT
    L1, L2 DES LISTES ;
DEBUT
    SI L1 = NIL
        Tous := VRAI
    SINON
        SI NON Rech ( L2, VALEUR ( L1 ) )
            Tous := FAUX
        SINON
            Tous := Tous ( SUIVANT ( L1 ), L2 )
        FSI
    FSI
FIN
```

This covers the primary syntax elements described in the provided document for the Z language used within Khawarizm.
The explanations and examples are derived directly from the OCR text.
Formatting is kept to plain text with indentation for readability.
The length is substantial, reflecting the request for detail.
```


''')

# Create document chain
document_chain = create_stuff_documents_chain(llm, prompt)

# Create retrieval chain
retriever = db.as_retriever(
    search_kwargs={"k": 6}  # Retrieve top 4 most relevant documents
)


retriever_chain = create_retrieval_chain(retriever, document_chain)

# Example usage


def query_system(question):
    result = retriever_chain.invoke({'input': question})
    return result['answer']



# Example query
query = f"take this answer {response} for this question: {query}, correct the logic and syntaxical errors for program, "
response = query_system(query)

groqrr = response
print(response)

display(Markdown(response))

import pathlib
import google.generativeai as genai  # ‚úÖ Correct import
import httpx
import os
from dotenv import load_dotenv
# Configure API key (get yours from Google AI Studio)
print('hiiiii')

# Configure API key (get from https://aistudio.google.com/)
# Replace with your actual key
# Load variables from .env file into environment
load_dotenv()

# Configure with API key from environment variable
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

# Path to your LOCAL PDF file
# üö® Update this to your actual file path

# Read PDF bytes from local file

# Initialize the model
# Check for latest model names
model = genai.GenerativeModel("gemini-2.5-pro-exp-03-25")

# Generate response
response = model.generate_content(
    [
        fr"""
-a chat bot was asked this quesion: {query}\n
-and the chabot gave me this response
{groqrr}\n
-and you have to do all this:
take this text ad try to preserve the same asnwer style,
if the response has fractions or integrals then keep their big sizes an keep gaps between expressions
correct the logic for equations, algorithems, programs, methods, and check if program and script works, if the logic is false try to improve it or correct
don't add anything except correcting tht original ,  don't add things from you like explaination or examples
give the output as a markdown file
""",  # Your prompt
        # PDF data
    ]
)

print(response.text)
print('finnn')

display(Markdown(response.text))

