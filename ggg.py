# -*- coding: utf-8 -*-
"""ggg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-OTVMUBrEu6aK5dN2PPhIQnkCHTfKgYe
"""

from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.document_loaders import TextLoader, WebBaseLoader, PyPDFLoader, DirectoryLoader, UnstructuredMarkdownLoader
import bs4
import os

# Document loading
loader = DirectoryLoader(
    path="dd",  # Replace with your folder path
    loader_cls=UnstructuredMarkdownLoader,
    use_multithreading=True
)

txt = loader.load()
from langchain.embeddings.sentence_transformer import SentenceTransformerEmbeddings
from langchain_community.vectorstores import FAISS
from pydantic.v1 import BaseModel, Field
import os

# Add this before your FAISS imports
class VectorStoreConfig(BaseModel):
    class Config:
        arbitrary_types_allowed = True


# Text splitting
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000,
    chunk_overlap=200,
    separators=[
        # ----- Markdown -----
        r"\n# ", r"\n## ", r"\n### ", r"\n#### ",
        r"\n```\n",
        r"\n\*\*\*\n", r"\n---\n",

        # ----- LaTeX/Math -----
        r"\n\\begin{equation}",
        r"\n\\begin{align}",
        r"\n\\section{", r"\n\\subsection{",
        r"\n\$\$", r"\n\\\[",

        # ----- C Code -----
        r"\n}\n",
        r"\n// -{4,}\n",
        r"\n#ifdef ", r"\n#endif",
        r"\n}\n\n",

        # ----- Assembly -----
        r"\n\.section\s",
        r"\n\.global\s",
        r"\n[a-zA-Z_]+:\n",
        r"\n; -{4,}\n",

        # ----- Generic Fallbacks -----
        r"\n\n", r"\n", r" ", r""
    ],
    is_separator_regex=True,
    keep_separator=True,
    strip_whitespace=True,
)
fdocs = text_splitter.split_documents(txt)

# Embedding with CPU optimization
embeddings = SentenceTransformerEmbeddings(
    model_name="all-MiniLM-L12-v2",
    model_kwargs={"device": "cpu"},
    encode_kwargs={
        "batch_size": 64,
        "normalize_embeddings": True
    }
)

# Create FAISS index
db = FAISS.from_documents(
    documents=fdocs,
    embedding=embeddings,
    normalize_L2=True
)

# To load it back later:
# loaded_db = FAISS.load_local(save_directory, embeddings)

# Now let's modify to use GROQ API instead of Ollama
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain_groq import ChatGroq  # Import the GROQ chat model
from langchain_core.prompts import ChatPromptTemplate
import os

# Set your GROQ API key - make sure to keep this secure!
# Import API key from environment variables or .env file

# Load variables from .env file into environment
load_dotenv()

# Access API key from environment variables
os.environ["GROQ_API_KEY"] = os.getenv("GROQ_API_KEY")

# Initialize the GROQ LLM - replaced Ollama with GROQ
llm = ChatGroq(
    # model="llama3-70b-8192",  # You can choose "mixtral-8x7b-32768" or other models
    # You can choose "mixtral-8x7b-32768" or other models
    model='llama-3.3-70b-versatile',
    temperature=0,
    max_tokens=32768,  # Control response length
)

# The prompt template remains the same
prompt = ChatPromptTemplate.from_template(r'''[Contexte] {context}
[Question] {input}
# Syntaxe Détaillée du Langage Z

## 1. Introduction et Objectifs du Langage Z









Le langage Z est un langage algorithmique conçu principalement à des fins pédagogiques. Son objectif est d'enseigner l'algorithmique et les structures de données en permettant aux utilisateurs d'écrire des algorithmes abstraits. Ces algorithmes sont basés sur des modèles de machines abstraites, ce qui permet de se concentrer sur la logique de résolution de problèmes avant de passer à une implémentation dans un langage de programmation spécifique comme Pascal ou C.

**Caractéristiques Clés pour l'IA :**
* Abstraction de la représentation mémoire.
* Syntaxe claire et structurée, facilitant l'analyse et la génération.
* Support des structures de données fondamentales.
* Modularité via les actions et les fonctions.

## 2. Structure Générale d'un Z-Algorithme

Un Z-algorithme est organisé en modules. Le premier module est toujours le module principal. Les modules suivants peuvent être des actions (procédures) ou des fonctions.

```Z
ALGORITHME Nom_Algorithme  // Optionnel, mais bon pour la clarté

SOIENT
    // Section des déclarations globales
    // Déclaration des constantes globales
    // Déclaration des types globaux
    // Déclaration des variables globales
    // Annonces des modules (actions et fonctions) qui seront définis plus bas

DEBUT // Début du module principal
    // Instructions du module principal
FIN // Fin du module principal

// Définition des modules (Actions et Fonctions) annoncés
ACTION Nom_Action_1 (paramètres)
    SOIENT
        // Déclarations locales à l'action
    DEBUT
        // Instructions de l'action
    FIN

FONCTION Nom_Fonction_1 (paramètres) : Type_Retour
    SOIENT
        // Déclarations locales à la fonction
    DEBUT
        // Instructions de la fonction
        Nom_Fonction_1 := Valeur_De_Retour // Instruction de retour
    FIN

// ... autres actions et fonctions
```

**Points importants pour l'IA :**
* Identifier la délimitation claire entre la section `SOIENT` (déclarations) et `DEBUT`/`FIN` (bloc d'instructions).
* Reconnaître le module principal comme point d'entrée.
* Comprendre la portée des variables (globales vs. locales à un module).
* Les annonces de modules dans `SOIENT` avant leur définition complète.

 3. Commentaires
Les commentaires sont essentiels pour la lisibilité et peuvent être ignorés par l'interpréteur ou le compilateur.


**Points importants pour l'IA :**
* Le modèle doit apprendre à identifier et potentiellement ignorer le contenu des commentaires lors de l'analyse de la logique du code.
* Lors de la génération de code, le modèle pourrait être entraîné à insérer des commentaires pertinents.

 4. Identificateurs

Les identificateurs sont les noms donnés aux variables, constantes, types, actions, fonctions, etc.
* Doivent commencer par une lettre.
* Peuvent contenir des lettres, des chiffres et le caractère souligné (`_`).
* Ne sont pas sensibles à la casse (par convention, mais à vérifier si les outils fournis le sont).
* Ne doivent pas être des mots-clés réservés du langage.

**Exemples :**
`Compteur`, `Total_Somme`, `Est_Valide`, `Ma_Procedure`

**Points importants pour l'IA :**
* Apprendre les règles de formation des identificateurs valides.
* Distinguer les identificateurs des mots-clés.

 5. Mots-Clés Réservés

Le langage Z possède un ensemble de mots-clés qui ont une signification spéciale et ne peuvent pas être utilisés comme identificateurs.
Voici une liste non exhaustive (à compléter à partir de l'index des mots-clés du document `Khawarizm_.pdf`) :

`ACTION`, `ALGORITHME`, `APPEL`, `ARB`, `ARM`, `BOOLEEN`, `BOOLEENS`, `CAR`, `CARACTERE`, `CARACTERES`, `CHAINE`, `CHAINES`, `CONST`, `CREERFILE`, `CREERNOEUD`, `CREERPILE`, `CREER_ARB`, `CREER_ARM`, `CREER_FILE`, `CREER_LISTE`, `DE`, `DEBUT`, `DEFILER`, `DEPILER`, `DES`, `ECRIRE`, `ELEMENT`, `EMPILER`, `ENFILER`, `ENTIER`, `ENTIERS`, `ET`, `FAUX`, `FICHIER`, `FILE`, `FIN`, `FINSI`, `FINTANTQUE`, `FINPOUR`, `FONCTION`, `LIRE`, `LISTE`, `MOD`, `NIL`, `NON`, `OU`, `PILE`, `POUR`, `PROCEDURE` (synonyme d'ACTION), `REEL` (à vérifier si supporté, les documents mentionnent principalement ENTIER), `REPETER`, `RETOURNE` (pourrait être utilisé avec FONCTION), `SI`, `SINON`, `SOIT`, `SOIENT`, `STRUCT`, `TABLEAU`, `TANTQUE`, `TYPE`, `UN`, `UNE`, `VECTEUR`, `VRAI`.

**Points importants pour l'IA :**
* Mémoriser cette liste pour éviter les conflits lors de la génération de noms.
* Utiliser ces mots-clés pour comprendre la structure et la sémantique du code.

6. Types de Données

 6.1. Types Scalaires Standards

* **ENTIER**: Pour les nombres entiers (positifs, négatifs ou nuls).
    * Exemple de déclaration : `Age : ENTIER`
* **BOOLEEN**: Pour les valeurs logiques.
    * Valeurs possibles : `VRAI`, `FAUX`.
    * Exemple de déclaration : `Trouve : BOOLEEN`
* **CAR**: Pour un caractère unique.
    * Les littéraux caractères sont souvent entourés d'apostrophes (ex: `'A'`).
    * Exemple de déclaration : `Lettre : CAR`
* **CHAINE**: Pour les séquences de caractères.
    * Les littéraux chaînes sont souvent entourés de guillemets (ex: `"Bonjour"`).
    * Exemple de déclaration : `Message : CHAINE`

### 6.2. Types Composés

Le langage Z permet de définir des types plus complexes :

* **Tableaux / Vecteurs**: Collections d'éléments de même type, accessibles par un ou plusieurs indices.
    * Syntaxe de déclaration : `Mon_Tableau : TABLEAU [borne_inf..borne_sup] DE Type_Element`
    * Exemple : `Notes : TABLEAU [1..20] DE ENTIER`
    * Les vecteurs peuvent être statiques ou dynamiques (`ALLOC_TAB`, `LIBER_TAB`).

* **Structures (Enregistrements)**: Collections d'éléments de types potentiellement différents, appelés champs, accessibles par leur nom.
    * Syntaxe de déclaration de type :
        ```Z
        TYPE
            Nom_Type_Structure = STRUCTURE
                Champ1 : Type1 ;
                Champ2 : Type2 ;
                // ...
            FINSTRUCTURE // ou FIN STRUCT
        ```
    * Déclaration de variable : `Ma_Var : Nom_Type_Structure`
    * Exemple :
        ```Z
        TYPE
            Personne = STRUCTURE
                Nom : CHAINE[30] ; // Chaîne de longueur fixe
                Age : ENTIER ;
            FINSTRUCTURE
        SOIENT
            Etudiant : Personne ;
        ```
    * Les structures peuvent être statiques ou dynamiques (`ALLOC_STRUCT`, `LIBER_STRUCT`).

* **Pointeurs**: Utilisés pour les structures de données dynamiques (listes, arbres). Un pointeur contient l'adresse d'une variable.
    * Syntaxe de déclaration : `Ptr_Var : ^Type_Cible` (la notation exacte peut varier, se référer aux exemples des PDFs).
    * Valeur spéciale : `NIL` (indique que le pointeur ne pointe sur rien).

* **Listes Linéaires Chaînées**: Séquences d'éléments (nœuds) où chaque nœud contient une donnée et un pointeur vers le nœud suivant (et précédent pour les listes bilatérales).
    * Implique la définition d'un type nœud (structure) et l'utilisation de pointeurs.
    * Opérations typiques : `CREER_LISTE`, `INSERER`, `SUPPRIMER`, `CHERCHER`.

* **Files d'attente (Queues)**: Structure de type FIFO (Premier Entré, Premier Sorti).
    * Opérations typiques : `CREER_FILE`, `ENFILER`, `DEFILER`, `FILE_VIDE`.

* **Piles (Stacks)**: Structure de type LIFO (Dernier Entré, Premier Sorti).
    * Opérations typiques : `CREER_PILE`, `EMPILER`, `DEPILER`, `PILE_VIDE`.

* **Arbres (Binaires, M-aires)**: Structures de données hiérarchiques.
    * Implique la définition d'un type nœud.
    * Opérations typiques : `CREER_ARB`, `CREERNOEUD`, `FG` (fils gauche), `FD` (fils droit), `PERE`.

* **Fichiers**: Pour la persistance des données.
    * Déclaration : `Mon_Fichier : FICHIER DE Type_Element`
    * Opérations : `OUVRIR`, `FERMER`, `LIRESEQ`, `ECRIRESEQ`.

* **Types Composés Complexes**: Le langage Z permet des imbrications comme `PILE DE FILES DE LISTES DE ENTIER`.
    * Exemple : `MaStructureComplexe : PILE DE LISTE DE CAR`

**Points importants pour l'IA :**
* Reconnaître les mots-clés de chaque type.
* Comprendre la syntaxe de déclaration pour chaque type (dimensions pour les tableaux, champs pour les structures, etc.).
* Associer les opérations de haut niveau (ex: `EMPILER`) avec le type de données correspondant (ex: `PILE`).

## 7. Déclarations

Toutes les entités (constantes, types, variables, modules) doivent être déclarées avant leur utilisation. Les déclarations se font principalement dans la section `SOIENT`.

### 7.1. Déclaration de Constantes

Permet de donner un nom à une valeur fixe.
Syntaxe : `CONST Nom_Constante = Valeur ;`
Exemple : `CONST PI = 3.14159 ;`
Exemple : `CONST MAX_TAILLE = 100 ;`

### 7.2. Déclaration de Types

Permet de définir de nouveaux types de données (surtout pour les structures, tableaux, etc.).
Syntaxe :
```Z
TYPE
    Nouveau_Nom_Type = Définition_Type ;
    // ... autres définitions de type
```
Exemple (déjà vu pour les structures) :
```Z
TYPE
    Point = STRUCTURE
        X, Y : ENTIER ;
    FINSTRUCTURE
```

### 7.3. Déclaration de Variables

Associe un nom à un emplacement mémoire qui peut stocker une valeur d'un type donné.
Syntaxe générale : `[SOIT | SOIENT] Liste_Identificateurs <Séparateur> Type_Donnée ;`
* `Liste_Identificateurs`: Un ou plusieurs noms de variables, séparés par des virgules.
* `<Séparateur>`: Peut être `:`, `UN`, `UNE`, `DES`. Le choix est souvent stylistique ou pour la lisibilité.
* `Type_Donnée`: Un type standard ou un type préalablement défini.

Exemples :
`SOIENT I, J, K : ENTIER ;`
`SOIT Nom_Utilisateur UNE CHAINE ;`
`SOIENT Scores DES TABLEAU [1..10] DE ENTIER ;`
`SOIT P1 UN Point ;`

### 7.4. Annonce de Modules (Actions et Fonctions)

Avant de définir une action ou une fonction (si elle n'est pas définie avant son premier appel, ce qui est la norme pour les définitions après le module principal), elle doit être annoncée dans la section `SOIENT` du module qui l'appelle ou globalement.
Syntaxe Annonce Action : `ACTION Nom_Action (Liste_Paramètres_Formels_Avec_Types) ;`
Syntaxe Annonce Fonction : `FONCTION Nom_Fonction (Liste_Paramètres_Formels_Avec_Types) : Type_Retour ;`

Exemple :
```Z
SOIENT
    // ... autres déclarations
    ACTION Afficher_Message (Msg : CHAINE) ;
    FONCTION Calculer_Somme (A, B : ENTIER) : ENTIER ;
```

**Points importants pour l'IA :**
* Identifier le type de déclaration (constante, type, variable, module).
* Extraire le nom, le type et la valeur (pour les constantes) ou la structure (pour les types).
* Comprendre la portée des déclarations (globale si dans `SOIENT` du module principal, locale sinon).

## 8. Expressions

Une expression est une combinaison de valeurs (littéraux, constantes, variables), d'opérateurs et d'appels de fonctions, qui s'évalue en une unique valeur.

### 8.1. Expressions Arithmétiques
Opérateurs : `+` (addition), `-` (soustraction, unaire moins), `*` (multiplication), `/` (division réelle), `DIV` (division entière), `MOD` (modulo).
Priorité des opérateurs : `*`, `/`, `DIV`, `MOD` ont une priorité plus élevée que `+`, `-`. Les parenthèses `()` peuvent être utilisées pour forcer l'ordre d'évaluation.
Exemple : `(A + B) * C / 2`

### 8.2. Expressions Logiques (Booléennes)
Opérateurs : `ET` (ET logique), `OU` (OU logique), `NON` (NON logique).
Valeurs : `VRAI`, `FAUX`.
Exemple : `(Age >= 18) ET (Est_Etudiant OU A_Reduction)`
Exemple : `NON Trouve`

### 8.3. Expressions Relationnelles (de Comparaison)
Opérateurs : `=`, `<>` (ou `#` pour différent), `<`, `<=`, `>`, `>=`.
Résultat : Toujours une valeur booléenne (`VRAI` ou `FAUX`).
Exemple : `X > Y`, `Nom = "Test"`

### 8.4. Expressions sur Chaînes de Caractères
Opérateur : `+` (concaténation).
Exemple : `"Bonjour" + " " + Nom_Utilisateur`

### 8.5. Accès aux Éléments de Types Composés
* Tableaux : `Nom_Tableau[Index]`
    Exemple : `Notes[I]`
* Structures : `Nom_Variable_Structure.Nom_Champ`
    Exemple : `Etudiant.Age`
* Pointeurs (déréférencement) : `Nom_Pointeur^` (pour accéder à la valeur pointée) ou `Nom_Pointeur^.Champ` si le pointeur pointe sur une structure. La notation exacte peut varier (ex: `INFO(P)` pour le contenu d'un nœud pointé par P dans une liste). Se référer aux opérations spécifiques des structures de données dans les PDFs.

### 8.6. Appels de Fonctions
Une fonction, lorsqu'elle est appelée dans une expression, retourne une valeur qui est utilisée dans le calcul de l'expression.
Syntaxe : `Nom_Fonction (Paramètre_Actuel_1, Paramètre_Actuel_2, ...)`
Exemple : `Resultat := Calculer_Somme(N1, N2) + 10`

**Points importants pour l'IA :**
* Parser correctement les expressions en respectant la priorité des opérateurs.
* Identifier le type résultant d'une expression.
* Gérer les appels de fonction et l'accès aux éléments de structures de données.

## 9. Instructions (Actions Élémentaires et Structures de Contrôle)

Les instructions décrivent les opérations à effectuer.

### 9.1. Affectation
Attribue la valeur d'une expression à une variable.
Syntaxe : `Nom_Variable := Expression ;`
Le type de `Expression` doit être compatible avec le type de `Nom_Variable`.
Exemples :
`Compteur := Compteur + 1 ;`
`Message_Bienvenue := "Bonjour !" ;`
`Est_Majeur := Age >= 18 ;`
`Mon_Tableau[Indice] := Valeur ;`
`Mon_Record.Champ := Autre_Valeur ;`

L'affectation globale est permise pour les types composés (ex: copier une structure entière dans une autre de même type).

### 9.2. Lecture (Entrée)
Permet d'obtenir des données depuis une source d'entrée standard (généralement le clavier) et de les stocker dans des variables.
Syntaxe : `LIRE ( Variable_1, Variable_2, ... ) ;`
Exemple : `LIRE ( Age, Nom ) ;`

### 9.3. Écriture (Sortie)
Permet d'afficher les valeurs d'expressions ou des messages sur une sortie standard (généralement l'écran).
Syntaxe : `ECRIRE ( Expression_1, Expression_2, ... ) ;`
Les expressions peuvent être des littéraux, des variables, ou des calculs plus complexes.
Exemple : `ECRIRE ( "Le résultat est : ", Somme / Nombre_Elements ) ;`
Exemple : `ECRIRE ( "Bonjour ", Nom_Utilisateur, " !" ) ;`

### 9.4. Structures de Contrôle

#### 9.4.1. Conditionnelle (SI ... SINON ... FINSI)
Exécute des blocs d'instructions en fonction de la valeur d'une condition booléenne.
* Forme simple :
    ```Z
    SI Condition_Booleenne [ALORS | :] // ALORS ou : est optionnel, : est fréquent
        // Bloc d'instructions si la condition est VRAI
    FINSI
    ```
* Forme avec alternative :
    ```Z
    SI Condition_Booleenne [ALORS | :]
        // Bloc d'instructions si la condition est VRAI
    SINON
        // Bloc d'instructions si la condition est FAUX
    FINSI
    ```
* Imbrication :
    ```Z
    SI Condition_1 :
        // ...
    SINON
        SI Condition_2 :
            // ...
        SINON
            // ...
        FINSI
    FINSI
    ```
Exemple :
```Z
SI Note >= 10 :
    ECRIRE ( "Admis" ) ;
SINON
    ECRIRE ( "Ajourné" ) ;
FINSI
```

#### 9.4.2. Boucle TANTQUE (Tant que ... Faire)
Répète un bloc d'instructions tant qu'une condition booléenne reste vraie. La condition est testée avant chaque itération.
Syntaxe :
```Z
TANTQUE Condition_Booleenne [FAIRE | :] // FAIRE ou : est optionnel
    // Bloc d'instructions à répéter
FINTANTQUE // ou FTQ
```
Exemple :
```Z
SOIENT I : ENTIER ;
I := 1 ;
TANTQUE I <= 10 :
    ECRIRE ( I ) ;
    I := I + 1 ;
FINTANTQUE
```

#### 9.4.3. Boucle POUR (Pour ... De ... À ...)
Répète un bloc d'instructions un nombre déterminé de fois, en utilisant une variable compteur.
Syntaxe :
```Z
POUR Variable_Compteur := Valeur_Initiale , Valeur_Finale [, Pas] [FAIRE | :] // Pas est optionnel, défaut 1
    // Bloc d'instructions à répéter
FINPOUR // ou FPOUR
```
* `Variable_Compteur` : Doit être d'un type ordinal (généralement ENTIER).
* `Valeur_Initiale`, `Valeur_Finale` : Expressions évaluant au type du compteur.
* `Pas` (optionnel) : Expression entière. Si positif, le compteur est incrémenté. Si négatif, il est décrémenté. Si omis, le pas est de `1`.

Exemple (incrémentation) :
```Z
POUR I := 1 , 5 : // Pas de 1 par défaut
    ECRIRE ( "Itération numéro : ", I ) ;
FINPOUR
```
Exemple (décrémentation avec pas explicite) :
```Z
POUR J := 10 , 1 , -2 :
    ECRIRE ( J ) ;
FINPOUR // Affichera 10, 8, 6, 4, 2
```

#### 9.4.4. Boucle REPETER ... JUSQU'A (À vérifier si présent dans les documents Z fournis)
Répète un bloc d'instructions jusqu'à ce qu'une condition devienne vraie. Le bloc est exécuté au moins une fois car la condition est testée après l'itération.
Syntaxe (typique, à confirmer pour Z) :
```Z
REPETER
    // Bloc d'instructions
JUSQU'A Condition_Booleenne
```
*Note : Les documents fournis se concentrent sur `TANTQUE` et `POUR`. Si `REPETER...JUSQU'A` est supporté, sa syntaxe exacte doit être vérifiée.*

**Points importants pour l'IA :**
* Identifier chaque type d'instruction.
* Pour les affectations, valider la compatibilité des types.
* Pour les structures de contrôle, identifier la condition et les blocs d'instructions associés.
* Comprendre la sémantique de chaque boucle (condition de test, modification du compteur).

## 10. Modules : Actions et Fonctions

Les modules permettent de structurer le code, de le réutiliser et de le rendre plus lisible.

### 10.1. Actions (Procédures)
Un bloc d'instructions nommé qui peut être appelé pour effectuer une tâche spécifique. Ne retourne pas de valeur directement (mais peut modifier des variables passées en paramètre ou des variables globales).

* **Annonce (Déclaration anticipée)**: (Vue dans la section Déclarations)
    `ACTION Nom_Action (P1:Type1 ; P2:Type2 ; ... ) ;`
    Les paramètres dans l'annonce incluent leurs types.

* **Définition**:
    ```Z
    ACTION Nom_Action (P_formel_1 [:Type1] ; P_formel_2 [:Type2] ; ... ) // Types optionnels ici si déjà dans l'annonce, mais bon pour la clarté
        SOIENT
            // Déclarations locales (variables, constantes, types spécifiques à l'action)
        DEBUT
            // Corps de l'action (instructions)
        FIN
    ```
    Les paramètres formels (`P_formel_1`, etc.) sont des placeholders pour les valeurs qui seront passées lors de l'appel.
    Le passage de paramètres en Z est **par référence** (ou adresse) par défaut. Cela signifie que si l'action modifie un paramètre, la variable originale passée lors de l'appel est modifiée. (Il est important de vérifier s'il existe un mécanisme de passage par valeur explicitement).

* **Appel**:
    `APPEL Nom_Action (Param_Actuel_1, Param_Actuel_2, ... ) ;`
    Ou plus simplement : `Nom_Action (Param_Actuel_1, Param_Actuel_2, ... ) ;` (L'utilisation de `APPEL` est souvent une convention plus ancienne ou pour la clarté).
    Les paramètres actuels sont les valeurs ou variables réelles passées à l'action.

Exemple :
```Z
SOIENT
    ACTION Afficher_Somme (A:ENTIER ; B:ENTIER) ; // Annonce

// ... dans le module principal ...
DEBUT
    // ...
    APPEL Afficher_Somme (Nombre1, Nombre2) ;
    // ...
FIN

// Définition de l'action
ACTION Afficher_Somme (A:ENTIER ; B:ENTIER)
    SOIENT
        Somme_Locale : ENTIER ;
    DEBUT
        Somme_Locale := A + B ;
        ECRIRE ( "La somme est : ", Somme_Locale ) ;
    FIN
```

### 10.2. Fonctions
Similaires aux actions, mais elles **retournent une valeur** d'un type spécifié.

* **Annonce (Déclaration anticipée)**: (Vue dans la section Déclarations)
    `FONCTION Nom_Fonction (P1:Type1 ; P2:Type2 ; ... ) : Type_Retour ;`

* **Définition**:
    ```Z
    FONCTION Nom_Fonction (P_formel_1 [:Type1] ; P_formel_2 [:Type2] ; ... ) : Type_Retour
        SOIENT
            // Déclarations locales
        DEBUT
            // Corps de la fonction (instructions)
            // ...
            Nom_Fonction := Expression_De_Retour ; // Instruction cruciale pour retourner la valeur
            // ...
        FIN
    ```
    L'instruction `Nom_Fonction := Expression_De_Retour ;` assigne la valeur à retourner au nom de la fonction elle-même. C'est ainsi que la valeur est renvoyée à l'appelant.
    Le passage de paramètres est également par référence par défaut.

* **Appel**:
    Une fonction est appelée dans une expression, là où une valeur de son type de retour est attendue.
    `Variable_Resultat := Nom_Fonction (Param_Actuel_1, Param_Actuel_2, ... ) ;`
    `ECRIRE ( "Résultat : ", Nom_Fonction(X, Y) ) ;`



''')

# Create document chain
document_chain = create_stuff_documents_chain(llm, prompt)

# Create retrieval chain
retriever = db.as_retriever(
    search_kwargs={"k": 6}  # Retrieve top 4 most relevant documents
)

from langchain.chains import create_retrieval_chain

retriever_chain = create_retrieval_chain(retriever, document_chain)

# Example usage
def query_system(question):
    result = retriever_chain.invoke({'input': question})
    return result['answer']

# Example query
from pprint import pprint

# Example query
query = "give a program using Z language to insert a list and calculate the sum of its elements and display the elements of the list, wihout using fucntions just global code"
response = query_system(query)

groqrr= response
print( response)
from IPython.display import Markdown, display

from pprint import pprint
display(Markdown(response))

# To load it back later:
# loaded_db = FAISS.load_local(save_directory, embeddings)

# Now let's modify to use GROQ API instead of Ollama
from IPython.display import Markdown, display
from pprint import pprint
from langchain.chains import create_retrieval_chain
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain_groq import ChatGroq  # Import the GROQ chat model
from langchain_core.prompts import ChatPromptTemplate
import os

# Set your GROQ API key - make sure to keep this secure!
# Replace with your actual API key
os.environ["GROQ_API_KEY"] = "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"

# Initialize the GROQ LLM - replaced Ollama with GROQ
llm = ChatGroq(
    # model="llama3-70b-8192",  # You can choose "mixtral-8x7b-32768" or other models
    # You can choose "mixtral-8x7b-32768" or other models
    model='llama-3.3-70b-versatile',
    temperature=0,
    max_tokens=32768,  # Control response length
)

# The prompt template remains the same
prompt = ChatPromptTemplate.from_template(r'''[Contexte] {context}
[Question] {input}
#
1.  STANDARD SCALAR TYPES (from Page 13, 17):
    Four standard scalar types are authorized:
    *   `ENTIER` (Integer)
    *   `BOOLEEN` (Boolean)
    *   `CARACTERE` (Character)
    *   `CHAINE` (String)

2.  SCALAR VARIABLE DECLARATION (from Page 17):
    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> <Type_Standard>`

    *   `SOIT` / `SOIENT`: Optional keywords (conventionally used).
    *   `<Liste_Identificateurs>`: A list of identifiers separated by commas (e.g., `X, Y, Z`).
    *   `<Separateur_Type>`: Can be one of `:`, `UN`, `UNE`, `DES`.
    *   `<Type_Standard>`: One of `ENTIER`, `BOOLEEN`, `CARACTERE`, `CHAINE` (or `ENTIERS`, `BOOLEENS`, `CHAINES` if plural form of separator is used, although the document isn't perfectly consistent here, `BOOLEENS` is shown with `:`)

    Examples (from Page 17):
    ```
    A, B, Trouv : BOOLEENS ;
    X, Y, Z DES BOOLEENS ;
    A : ENTIERS ;  // Assuming ENTIERS is a valid plural like BOOLEENS
    A : ENTIER ;   // More likely based on standard types
    X, Y, Z DES CHAINES ;
    ```

3.  POINTERS (Objets "Pointeurs") (from Page 17, 18):
    Used for manipulating data structures.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> POINTEUR VERS [<Separateur_Cible>] [DE <Type_Compose_Element> DE <Type_Compose_Element> ...] [DE <Type_Scalaire_Ou_Structure_Simple>]`

    *   `<Separateur_Cible>`: Optional, from `UN, UNE, DES`.
    *   `<Type_Compose_Element>`: One of `VECTEUR`, `PILE`, `LISTE`, `FILE`, `ARB` (binary tree), `LISTEBI` (bidirectional list), `ARM` (m-ary tree).
        (Note: `PILE` is listed twice in the OCR on page 18, likely a typo.)
    *   `<Type_Scalaire_Ou_Structure_Simple>`: A scalar type or a simple structure type if it's the final element type.

    Remark (Page 18):
    `SOIT L UNE LISTE` is equivalent to `SOIT L UN POINTEUR VERS UNE LISTE`. This implies that direct data structure type declarations are implicitly pointer types.

    Examples (from Page 18):
    ```
    P1 : POINTEUR VERS LISTE DE PILE ;
    P2, P3 DES POINTEURS VERS DES ARB ; // Corrected P2, P2 to P2, P3 for clarity
    ```

4.  STRUCTURES (from Page 20):
    A heterogeneous collection of elements. Can be simple (only scalars) or complex (scalars and/or 1D vectors). Can be static or dynamic.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> [STRUCTURE] ( <Type1>, <Type2>, ... ) [DYNAMIQUE]`

    *   `STRUCTURE`: Optional keyword.
    *   `<TypeI>`: Can be a scalar type or a 1D vector (e.g., `VECTEUR(5) DE CHAINE`).
    *   `DYNAMIQUE`: Keyword for dynamic allocation.

    Examples (from Page 20):
    ```
    S1 : (ENTIER, CHAINE) ;
    S2 UNE STRUCTURE ( CHAINE, ENTIER, BOOLEEN) ;
    S3 UN (ENTIER, VECTEUR(5) DE CHAINE) DYNAMIQUE ;
    ```

5.  TABLEAUX (Arrays/Vectors) (from Page 20):
    A homogeneous collection of elements. Can be simple (scalar elements) or complex (simple structure elements). Can be static or dynamic.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> VECTEUR(<Dim1>[, <Dim2>, ...]) [DE <Type_Compose_Element> DE ... ] DE <Type_Element_Final> [DYNAMIQUE]`

    *   `VECTEUR(<Dim1>[, <Dim2>, ...])`: Specifies dimensions. `TABLEAU` can be used instead of `VECTEUR`.
    *   `DE <Type_Compose_Element>`: For arrays of complex types like `PILE`, `LISTE`.
    *   `DE <Type_Element_Final>`: The base type of elements (scalar or simple structure).
    *   `DYNAMIQUE`: Keyword for dynamic allocation.

    Examples (from Page 20):
    ```
    V1 UN TABLEAU (5) DYNAMIQUE ;  // Elements are of default type or needs further spec. based on context
    V2, V3 DES VECTEURS (3, 8) DE CHAINES ; // A 2D array of strings
    ```

6.  LISTES LINEAIRES CHAINEES (Singly Linked Lists) (from Page 21):
    Dynamically allocated chain of nodes. Each node has `Valeur` and `Adresse` (next).

    General Form (implicit pointer as per page 18 remark):
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> LISTE [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 21):
    ```
    L1 UNE LISTE DE (CHAINE, ENTIER) ; // A list where elements are structures of (CHAINE, ENTIER)
    L2 UNE LISTE DE PILE DE CHAINE ; // A list of stacks of strings
    L3 UNE LISTE DE CHAINES ; // A list of strings
    ```

7.  LISTES LINEAIRES CHAINEES BILATERALES (Doubly Linked Lists) (from Page 21):
    Nodes have `Valeur`, `adresse gauche` (previous), `adresse droite` (next).

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> LISTEBI [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 21):
    ```
    Lb1 UNE LISTEBI DE (CHAINE, ENTIER) ;
    Lb2 UNE LISTEBI DE PILE DE CHAINE ;
    Lb3 UNE LISTEBI DE CHAINES ;
    ```

8.  FILES D'ATTENTE (Queues - FIFO) (from Page 21):
    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> FILE [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 22):
    ```
    F1 UNE FILE DE (CHAINE, ENTIER) ;
    F2 UNE FILE DE PILE DE CHAINE ;
    F3 UNE FILE DE CHAINES ;
    ```

9.  PILES (Stacks - LIFO) (from Page 22):
    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> PILE [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 22):
    ```
    P1 UNE PILE DE (CHAINE, ENTIER) ;
    P2 UNE PILE DE PILE DE CHAINE ;
    P3 UNE PILE DE CHAINES ;
    ```

10. ARBRES DE RECHERCHE BINAIRE (Binary Search Trees) (from Page 22):
    Node structure: `(left_child, Value, right_child)`.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> ARB [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    Examples (from Page 23):
    ```
    A1 UN ARB DE (CHAINE, ENTIER) ;
    A2 UN ARB DE PILE DE CHAINE ;
    A3 UN ARB DE CHAINES ;
    ```

11. ARBRES DE RECHERCHE M-AIRE (M-ary Search Trees) (from Page 23):
    Node of order `p` contains `(p-1)` informations and `p` children.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> ARM (<degre>) [DE <Type_Compose_Element> DE ...] [DE <Type_Element_Final>]`

    *   `<degre>`: The order of the m-ary tree.

    Examples (from Page 23):
    ```
    M1 UN ARM(4) DE (CHAINE, ENTIER) ;
    M2 UN ARM(2) DE PILE DE CHAINE ; // An m-ary tree of order 2 is a binary tree
    M3 UN ARM(3) DE CHAINES ;
    ```

12. FICHIERS (Files) (from Page 23, 24):
    Set of records, typically on disk. Involves a mandatory header part for file structure design.
    A file definition has 3 parts:
    *   `FICHIER DE type_element`: Nature of file elements (scalar, 1D vector, or complex structure).
    *   `BUFFER <Liste_Tampons>`: Buffer variables for read/write operations.
    *   `ENTETE (<Type_Carac1>, <Type_Carac2>, ...)`: Optional. Defines file characteristics.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> FICHIER DE <Type_Element_Fichier> BUFFER <Liste_Variables_Tampon> [ENTETE (<Type_Carac1>, <Type_Carac2>, ...)]`

    Examples (from Page 24):
    ```
    F1 UN FICHIER DE CHAINES BUFFER V1, V2 ;
    F2 UN FICHIER DE VECTEUR(5) DE ENTIER BUFFER V ;
    F3 UN FICHIER DE (ENTIER, VECTEUR(3) DE CAR) BUFFER V ENTETE(ENTIER, ENTIER) ;
    F4 UN FICHIER DE CAR BUFFER V ENTETE (ENTIER, CHAINE, BOOLEEN) ;
    ```

13. DECLARING ABSTRACT MACHINES (from Page 25):
    Implicitly, declaring a variable of a data structure type (like LISTE, PILE, etc.) also makes the operations of its abstract machine available for that variable.

    General Form:
    `[SOIT | SOIENT] <Liste_Identificateurs> <Separateur_Type> <Nom_Machine_Abstraite_Ou_Type_DS>`

    Examples (from Page 25):
    ```
    L1, L2 DES LISTES ;
    F UNE FILE ;
    V1 UN VECTEUR(10, 60) ; // Assuming default element type or it implies a simple scalar
    Y UNE LISTE DE PILES DE VECTEUR(5) ;
    ```

================================================================================
III. EXPRESSIONS AND OPERATORS (from Page 18)
================================================================================

1.  ARITHMETIC EXPRESSIONS:
    Operators: `+`, `-`, `/`, `*`

2.  LOGICAL EXPRESSIONS:
    Operators: `ET`, `OU`, `NON`

3.  STRING EXPRESSIONS:
    Operator: `+` (concatenation)

4.  RELATIONAL EXPRESSIONS:
    Operators: `<`, `<=`, `>`, `>=`, `=`, `<>` (or `#` for not equal)

5.  CONSTANTS:
    *   Logical Constants: `VRAI`, `FAUX`
    *   Pointer Constant: `NIL` (used for uninitialized or end-of-list pointers)

    Examples (from Page 18):
    ```
    B+C/F
    NON Trouv
    (X # 5) ET NON TROUV
    F(X) <> 5
    P = NIL
    ```

================================================================================
IV. ACTIONS ELEMENTAIRES (from Page 15)
================================================================================

1.  AFFECTATION (Assignment):
    Assigns the value of an expression to a variable.
    Syntax: `V := Exp`

    Example:
    ```
    X := 10 ;
    Trouv := FAUX ;
    NomFonction := X + Y ; // Inside a function to set its return value
    ```

2.  LECTURE (Input):
    Reads data into variables.
    Syntax: `LIRE (V1, V2, ...)`

    Example:
    ```
    LIRE (Age, NomUtilisateur) ;
    ```

3.  ECRITURE (Output):
    Outputs the value of expressions.
    Syntax: `ECRIRE (Exp1, Exp2, ...)`
    (Can output entire expressions or character strings)

    Example:
    ```
    ECRIRE ("Le résultat est : ", Resultat, " unités.") ;
    ECRIRE (Tableau[i]) ;
    ```

================================================================================
V. STRUCTURES DE CONTROLE (from Page 14, 15)
================================================================================

1.  LA BOUCLE TANTQUE (While Loop):
    Syntax:
    ```
    TANTQUE <Expression_Booleenne> [:]
        <Instructions>
    FINTANTQUE
    ```
    *   `[:]`: Optional colon (purpose not explicitly defined, might be for style or indenter).
    *   `<Expression_Booleenne>`: The loop condition.
    *   `<Instructions>`: Statements executed as long as the condition is `VRAI`.

2.  LA BOUCLE POUR (For Loop):
    Syntax:
    ```
    POUR <Variable_Compteur> := <Expression_Debut>, <Expression_Fin> [,<Expression_Pas>] [:]
        <Instructions>
    FINPOUR
    ```
    *   `<Variable_Compteur>`: Loop counter variable.
    *   `<Expression_Debut>`: Initial value of the counter.
    *   `<Expression_Fin>`: Final value for the counter (loop continues while counter <= Fin).
    *   `<Expression_Pas>`: Optional. Increment step for the counter. Default is 1.
    *   `[:]`: Optional colon.

3.  LA CONDITIONNELLE (If Statement - Simple):
    Syntax:
    ```
    SI <Expression_Booleenne> [:]
        <Instructions>
    FINSI
    ```
    *   `[:]`: Optional colon.
    *   `<Instructions>`: Executed if `<Expression_Booleenne>` is `VRAI`.

4.  L'ALTERNATIVE (If-Else Statement):
    Syntax:
    ```
    SI <Expression_Booleenne> [:]
        <Instructions_Si_Vrai>
    SINON
        <Instructions_Si_Faux>
    FINSI
    ```
    *   `[:]`: Optional colon.

================================================================================
VI. MODULES: ACTIONS ET FONCTIONS
================================================================================

1.  ACTION COMPOSEE (Procedure) (from Page 16):
    A named block of code performing a specific task. Parameters are passed by "reference" (implying input parameters are not protected from modification within the action).
    An action must be announced (forward declared) in the main module.

    Definition Syntax:
    ```
    ACTION <Nom_Action> ( <Param1>, <Param2>, ..., <ParamN> )
        <Déclarations_Objets_Locaux_Et_Paramètres>
    DEBUT
        <Instructions>
    FIN
    ```

    Appel (Call) Syntax (from Page 17):
    `APPEL <Nom_Action> ( <Paramètres_Réels> )`

    Example Annonce (Conceptual):
    ```
    SOIENT
        UneAction : ACTION (p1:ENTIER, p2:CHAINE); // Annonce format not explicitly given, inferred
    ...
    ```

2.  FONCTION (Function) (from Page 17):
    A named block of code that computes and returns a value. Parameters are passed by "reference".
    A function must be announced in the main module, specifying its return type.
    The return value is set by assigning to the function's name within its body (`Nom := Expression`).

    Definition Syntax:
    ```
    FONCTION <Nom_Fonction> ( <Param1>, <Param2>, ..., <ParamN> ) : <Type_Retour>
        <Déclarations_Objets_Locaux_Et_Paramètres>
    DEBUT
        <Instructions>
        ...
        <Nom_Fonction> := <Expression_Resultat> ;
        ...
    FIN
    ```

    Appel (Call) Syntax:
    A function is called by using its name in an expression.
    Example: `Resultat := MaFonction(X, Y) + 5 ;`

    Example Annonce (from page 8, 18):
    ```
    SOIENT
        Rech, Tous : FONCTION (BOOLEEN);
    ...
    FONCTION Rech (L, Val) : BOOLEEN // L, Val types declared inside function's SOIENT
    ...
    ```

================================================================================
VII. FONCTIONS PREDEFINIES ET OPERATIONS DE HAUT NIVEAU
================================================================================

1.  FONCTIONS STANDARDS (from Page 16):
    *   `MOD (A, B)`: Remainder of integer division A by B.
    *   `MAX (A, B)`: Maximum of A and B.
    *   `MIN (A, B)`: Minimum of A and B.
    *   `EXP (A, B)`: A raised to the power of B (A exposant B).

2.  FONCTIONS DE GENERATION ALEATOIRE (Random Generation) (from Page 13, 16):
    *   `ALEACHAINE (N)`: Returns a random string of N characters (uppercase and lowercase alphabet).
    *   `ALEANOMBRE (N)`: Returns a random integer between 0 and N. (Page 16 has `ALEAENTIER`, page 13 `ALEANOMBRE`. `ALEANOMBRE` seems more consistent with `ALEACHAINE`).

3.  FONCTIONS SUR CHAINES DE CARACTERES (String Functions) (from Page 13, 16):
    *   `LONGCHAINE (C)`: Returns the length of string C.
    *   `CARACT (C, I)`: Returns the I-th character of string C.

4.  OPERATIONS DE HAUT NIVEAU (High-Level Operations for Data Structures) (from Page 15):
    These allow filling/initializing a data structure from a set of expressions.
    The expressions `Exp1, Exp2, ...` are scalar or simple structures.
    The list of values is enclosed in `[...]`.

    *   `INIT_VECT ( T, [<Exp1>, <Exp2>, ...] )`
        Initializes vector T.
    *   `INIT_STRUCT ( S, [<Exp1>, <Exp2>, ...] )`
        Initializes structure S.
    *   `CREER_LISTE ( L, [<Exp1>, <Exp2>, ...] )`
        Creates a singly linked list L with given values in order.
        Example: `CREER_LISTE (L, [12, 34, I, I+J, 45])`
    *   `CREER_LISTEBI ( LB, [<Exp1>, <Exp2>, ...] )`
        Creates a doubly linked list LB.
    *   `CREER_ARB ( A, [<Exp1>, <Exp2>, ...] )`
        Creates a binary search tree A. (Insertion order matters).
    *   `CREER_ARM ( M, [<Exp1>, <Exp2>, ...] )`
        Creates an m-ary tree M.
    *   `CREER_FILE ( F, [<Exp1>, <Exp2>, ...] )`
        Creates a queue F.
    *   `CREER_PILE ( P, [<Exp1>, <Exp2>, ...] )`
        Creates a stack P.

================================================================================
VIII. OPERATIONS DES MACHINES ABSTRAITES (from Pages 25-30)
================================================================================

These operations are used to manipulate instances of data structures.

1.  MACHINE ABSTRAITE SUR LES VECTEURS (Vectors/Arrays):
    *   `ELEMENT ( T[i, j, ...] )`: Accesses element at `T[i,j,...]`. Returns the element.
    *   `AFF_ELEMENT ( T[I, J, ...], Val )`: Assigns `Val` to element `T[I,J,...]`.
    *   `ALLOC_TAB ( T )`: Allocates memory for a dynamically declared array T. Address returned in T.
    *   `LIBER_TAB ( T )`: Frees memory pointed to by T.

2.  MACHINE ABSTRAITE SUR LES STRUCTURES (Structures):
    *   `STRUCT ( S, i )`: Accesses the i-th field of structure S. Returns the field's value.
    *   `AFF_STRUCT ( S, i, Exp )`: Assigns `Exp` to the i-th field of structure S.
    *   `ALLOC_STRUCT ( S )`: Allocates memory for a dynamically declared structure S. Address returned in S.
    *   `LIBER_STRUCT ( S )`: Frees memory pointed to by S.

3.  MACHINE ABSTRAITE SUR LES LISTES LINEAIRES CHAINEES (Singly Linked Lists):
    *   `ALLOUER ( P )`: Creates a new node and returns its address in P.
    *   `LIBERER ( P )`: Frees the node at address P.
    *   `SUIVANT ( P )`: Accesses the 'Adresse' (next pointer) field of the node P. Returns pointer.
    *   `VALEUR ( P )`: Accesses the 'Valeur' (data) field of the node P. Returns value.
    *   `AFF_ADR ( P, Q )`: Assigns address Q to the 'Adresse' (next pointer) field of node P. (P^.Suiv := Q).
    *   `AFF_VAL ( P, Val )`: Assigns `Val` to the 'Valeur' (data) field of node P. (P^.Val := Val).

4.  MACHINE ABSTRAITE SUR LES LISTES BIDIRECTIONNELLES (Doubly Linked Lists):
    *   `ALLOUER ( P )`: Creates a new node, returns address in P.
    *   `LIBERER ( P )`: Frees node at address P.
    *   `SUIVANT ( P )`: Accesses 'Adresse droite' (next pointer). Returns pointer.
    *   `PRECEDENT ( P )`: Accesses 'Adresse gauche' (previous pointer). Returns pointer.
    *   `VALEUR ( P )`: Accesses 'Valeur' (data) field. Returns value.
    *   `AFF_ADRD ( P, Q )`: Assigns Q to 'Adresse droite' of P (P^.Suiv := Q).
    *   `AFF_ADRG ( P, Q )`: Assigns Q to 'Adresse gauche' of P (P^.Prec := Q).
    *   `AFF_VAL ( P, Val )`: Assigns `Val` to 'Valeur' of P.

5.  MACHINE ABSTRAITE SUR LES FILES D'ATTENTE (Queues):
    *   `CREERFILE ( F )`: Creates an empty queue F.
    *   `FILEVIDE ( F )`: Tests if queue F is empty. Returns BOOLEEN.
    *   `ENFILER ( F, Val )`: Adds (enqueues) `Val` to the end of queue F.
    *   `DEFILER ( F, Var_Pour_Val )`: Removes (dequeues) value from front of F into `Var_Pour_Val`.

6.  MACHINE ABSTRAITE SUR LES PILES (Stacks):
    *   `CREERPILE ( P )`: Creates an empty stack P.
    *   `PILEVIDE ( P )`: Tests if stack P is empty. Returns BOOLEEN.
    *   `EMPILER ( P, Val )`: Pushes `Val` onto the top of stack P.
    *   `DEPILER ( P, Var_Pour_Val )`: Pops value from top of P into `Var_Pour_Val`.

7.  MACHINE ABSTRAITE SUR LES ARBRES DE RECHERCHE BINAIRE:
    *   `CREERNOEUD ( Val )`: Creates a new tree node with `Val` as info, children are NIL. Returns node address.
    *   `LIBERERNOEUD ( P )`: Frees node P.
    *   `FG ( P )`: Accesses left child (Fils Gauche) of node P. Returns pointer.
    *   `FD ( P )`: Accesses right child (Fils Droit) of node P. Returns pointer.
    *   `PERE ( P )`: Accesses parent of node P. Returns pointer.
    *   `INFO ( P )`: Accesses information/data field of node P. Returns value.
    *   `AFF_FG ( P, Q )`: Sets left child of P to Q.
    *   `AFF_FD ( P, Q )`: Sets right child of P to Q.
    *   `AFF_PERE ( P, Q )`: Sets parent of P to Q.
    *   `AFF_INFO ( P, Val )`: Sets information/data field of P to `Val`.

8.  MACHINE ABSTRAITE SUR LES ARBRES DE RECHERCHE M-AIRE:
    *   `CREERNOEUD ( Val )`: Creates a new tree node with `Val`. Returns node address. (Assumes `Val` might be the first info for m-ary or a general value for leaf).
    *   `LIBERERNOEUD ( P )`: Frees node P.
    *   `FILS ( P, I )`: Accesses the I-th child of node P. Returns pointer.
    *   `PERE ( P )`: Accesses parent of node P. Returns pointer.
    *   `INFOR ( P, I )`: Accesses the I-th information field of node P. Returns value.
    *   `AFF_FILS ( P, I, Q )`: Sets the I-th child of P to Q.
    *   `AFF_PERE ( P, Q )`: Sets parent of P to Q.
    *   `AFF_INFOR ( P, I, Val )`: Sets the I-th information field of P to `Val`.

9.  MACHINE ABSTRAITE SUR LES FICHIERS (Files):
    *   `OUVRIR ( Fl, Fp, Mode )`: Opens logical file `Fl`, associates with physical file `Fp`. `Mode` is 'N' (new) or 'A' (append/ancient).
    *   `FERMER ( Fl )`: Closes logical file `Fl`.
    *   `LIRESEQ ( Fl, V )`: Reads current block/record from `Fl` into buffer variable `V`.
    *   `ECRIRESEQ ( Fl, V )`: Writes content of buffer `V` to current position in `Fl`.
    *   `LIREDIR ( Fl, V, N )`: Reads N-th block/record from `Fl` into buffer `V`.
    *   `ECRIREDIR ( Fl, V, N )`: Writes content of buffer `V` to N-th position in `Fl`.
    *   `RAJOUTER ( Fl, V )`: Appends content of buffer `V` to the end of `Fl`.
    *   `FINFICH ( Fl )`: Predicate, true if end-of-file for `Fl` is reached, false otherwise.
    *   `ALLOC_BLOC ( Fl )`: Provides a block/article in the file `Fl` where one can write (typically returns index/offset for direct access or implies next available for sequential).
    *   `ENTETE ( Fl, I )`: Retrieves the I-th characteristic from the header of file `Fl`.
    *   `AFF_ENTETE ( Fl, I, Exp )`: Sets the I-th characteristic in the header of file `Fl` to `Exp`.

================================================================================
IX. EXAMPLES OF Z-ALGORITHMS (Illustrative fragments from document)
================================================================================

Example from Page 8 (List inclusion check):
```
SOIENT
    L1, L2 DES LISTES ;
    Rech, Tous : FONCTION ( BOOLEEN ) ;
DEBUT
    CREER_LISTE (L1, [2,5,9,8,3,6]) ;
    CREER_LISTE (L2, [12,5,19,8,3,6,2,9]) ;
    ECRIRE ( Tous (L1, L2) )
FIN

{{Recherche d'une valeur dans une liste linéaire chaînée}}
FONCTION Rech (L, Val) : BOOLEEN
SOIENT
    L UNE LISTE ;
    Val UN ENTIER ;
DEBUT
    SI L = NIL
        Rech := FAUX
    SINON
        SI VALEUR ( L ) = Val
            Rech := VRAI
        SINON
            Rech := Rech ( SUIVANT ( L ), Val)
        FSI
    FSI
FIN

Détermine si tous les éléments de L1 sont dans L2 - from page 9, adapted
FONCTION Tous ( L1, L2 ) : BOOLEEN
SOIENT
    L1, L2 DES LISTES ;
DEBUT
    SI L1 = NIL
        Tous := VRAI
    SINON
        SI NON Rech ( L2, VALEUR ( L1 ) )
            Tous := FAUX
        SINON
            Tous := Tous ( SUIVANT ( L1 ), L2 )
        FSI
    FSI
FIN
```

This covers the primary syntax elements described in the provided document for the Z language used within Khawarizm.
The explanations and examples are derived directly from the OCR text.
Formatting is kept to plain text with indentation for readability.
The length is substantial, reflecting the request for detail.
```


''')

# Create document chain
document_chain = create_stuff_documents_chain(llm, prompt)

# Create retrieval chain
retriever = db.as_retriever(
    search_kwargs={"k": 6}  # Retrieve top 4 most relevant documents
)


retriever_chain = create_retrieval_chain(retriever, document_chain)

# Example usage


def query_system(question):
    result = retriever_chain.invoke({'input': question})
    return result['answer']



# Example query
query = f"take this answer {response} for this question: {query}, correct the logic and syntaxical errors for program, "
response = query_system(query)

groqrr = response
print(response)

display(Markdown(response))

import pathlib
import google.generativeai as genai  # ✅ Correct import
import httpx
import os
from dotenv import load_dotenv
# Configure API key (get yours from Google AI Studio)
print('hiiiii')

# Configure API key (get from https://aistudio.google.com/)
# Replace with your actual key
# Load variables from .env file into environment
load_dotenv()

# Configure with API key from environment variable
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

# Path to your LOCAL PDF file
# 🚨 Update this to your actual file path

# Read PDF bytes from local file

# Initialize the model
# Check for latest model names
model = genai.GenerativeModel("gemini-2.5-pro-exp-03-25")

# Generate response
response = model.generate_content(
    [
        fr"""
-a chat bot was asked this quesion: {query}\n
-and the chabot gave me this response
{groqrr}\n
-and you have to do all this:
take this text ad try to preserve the same asnwer style,
if the response has fractions or integrals then keep their big sizes an keep gaps between expressions
correct the logic for equations, algorithems, programs, methods, and check if program and script works, if the logic is false try to improve it or correct
don't add anything except correcting tht original ,  don't add things from you like explaination or examples
give the output as a markdown file
""",  # Your prompt
        # PDF data
    ]
)

print(response.text)
print('finnn')

display(Markdown(response.text))

